<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lab Value Grapher</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      height: 100vh;
      display: flex;
    }
    .container {
      display: flex;
      flex: 1;
    }
    .left, .right {
      padding: 12px;
      box-sizing: border-box;
    }
    .left {
      width: 40%;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
    }
    .input-section, .output-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .input-section {
      border-bottom: 1px solid #ccc;
      padding-bottom: 8px;
    }
    .output-section {
      padding-top: 8px;
    }
    .input-section h4, .output-section h4 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }
    textarea {
      flex: 1;
      width: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 8px;
      box-sizing: border-box;
    }
    #outputArea {
      flex: 1;
      width: 100%;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
      padding: 8px;
      background: #f9f9f9;
      border: 1px solid #ccc;
      box-sizing: border-box;
      white-space: pre-wrap;
    }
    #outputArea .high {
      color: red;
      font-weight: bold;
    }
    #outputArea .low {
      color: blue;
      font-weight: bold;
    }
    .right {
      width: 60%;
      display: flex;
      flex-direction: column;
    }
    #status {
      font-size: 12px;
      color: #666;
      margin-bottom: 4px;
    }
    #chartContainer {
      flex: 1;
      min-height: 0;
    }
    #chartContainer svg {
      width: 100%;
      height: 100%;
    }
    .axis-label {
      font-size: 12px;
      fill: #666;
    }
    .axis-title {
      font-size: 12px;
      fill: #333;
    }
    .grid-line {
      stroke: #e0e0e0;
      stroke-width: 1;
    }
    .data-line {
      fill: none;
      stroke: #36a2eb;
      stroke-width: 2;
    }
    .data-point {
      fill: #36a2eb;
      cursor: pointer;
    }
    .data-point.out-of-range {
      fill: #ff4444;
    }
    .data-point:hover {
      fill: #1a7fc4;
      r: 6;
    }
    .data-point.out-of-range:hover {
      fill: #cc0000;
    }
    .ref-line {
      stroke: #ff6384;
      stroke-width: 1.5;
      stroke-dasharray: 5, 5;
    }
    .trend-line {
      stroke: #4caf50;
      stroke-width: 1.5;
      stroke-dasharray: 4, 4;
    }
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      z-index: 100;
    }
    .legend {
      display: flex;
      gap: 20px;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-line {
      width: 20px;
      height: 2px;
      background: #36a2eb;
    }
    .legend-line.ref {
      background: #ff6384;
      background: repeating-linear-gradient(
        90deg,
        #ff6384 0px,
        #ff6384 5px,
        transparent 5px,
        transparent 10px
      );
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="left">
      <div class="input-section">
        <h4>Paste Data Here</h4>
        <textarea id="dataInput" placeholder="Paste your lab data here..."></textarea>
        <small>
          Expected format: date on one line, value on the next line, e.g.<br>
          8/21/2018<br>
          0.89<br>
          Extra text like &quot;(H)&quot;, headers, and legends are ignored.
        </small>
      </div>
      <div class="output-section">
        <h4>Formatted Output</h4>
        <div id="outputArea"></div>
      </div>
    </div>
    <div class="right">
      <h3>Lab Values Over Time</h3>
      <div id="status">Waiting for data…</div>
      <div class="legend" id="legend" style="display: none;">
        <div class="legend-item">
          <div class="legend-line"></div>
          <span id="legendLabel">Lab Value</span>
        </div>
        <div class="legend-item" id="refLegend" style="display: none;">
          <div class="legend-line ref"></div>
          <span>Ref Limits</span>
        </div>
        <div class="legend-item" id="trendLegend" style="display: none;">
          <div class="legend-line" style="background: repeating-linear-gradient(90deg, #4caf50 0px, #4caf50 4px, transparent 4px, transparent 8px);"></div>
          <span>Linear Regression</span>
        </div>
      </div>
      <div id="trendInfo" style="font-size: 12px; color: #666; margin-bottom: 4px; display: none;"></div>
      <div id="chartContainer"></div>
      <div class="tooltip" id="tooltip"></div>
    </div>
  </div>

  <script>
    const textarea = document.getElementById('dataInput');
    const statusEl = document.getElementById('status');
    const chartContainer = document.getElementById('chartContainer');
    const tooltip = document.getElementById('tooltip');
    const legend = document.getElementById('legend');
    const refLegend = document.getElementById('refLegend');
    const trendLegend = document.getElementById('trendLegend');
    const trendInfo = document.getElementById('trendInfo');
    const outputArea = document.getElementById('outputArea');
    const legendLabel = document.getElementById('legendLabel');

    // Chart margins
    const margin = { top: 20, right: 30, bottom: 50, left: 60 };

    function parseData(text) {
      const lines = text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length > 0);

      if (lines.length === 0) {
        return null;
      }

      let refLow = null;
      let refHigh = null;
      let labName = null;

      // Try to detect lab name from the first non-empty line that's not a date or number
      const dateRegexCheck = /^\d{1,2}\/\d{1,2}\/\d{4}/;
      const numberRegexCheck = /^\d+(\.\d+)?/;
      const refRangeCheck = /^\s*\d+(\.\d+)?\s*-\s*\d+(\.\d+)?/;
      for (const line of lines) {
        if (!dateRegexCheck.test(line) && !numberRegexCheck.test(line) && !refRangeCheck.test(line) && !line.match(/^(Latest|Legend|High|\(H\)|\(L\))/i)) {
          labName = line;
          break;
        }
      }

      // Try to detect reference range like "0.70 - 1.30 mg/dL"
      for (const line of lines) {
        const m = line.match(/^\s*(\d+(\.\d+)?)\s*-\s*(\d+(\.\d+)?)/);
        if (m) {
          refLow = parseFloat(m[1]);
          refHigh = parseFloat(m[3]);
          break;
        }
      }

      const dateRegex = /^(\d{1,2})\/(\d{1,2})\/(\d{4})/;
      const valueRegex = /^(\d+(\.\d+)?)/;

      const dataPoints = [];

      for (let i = 0; i < lines.length; i++) {
        const dateMatch = lines[i].match(dateRegex);
        if (!dateMatch) continue;

        const month = parseInt(dateMatch[1], 10) - 1;
        const day = parseInt(dateMatch[2], 10);
        const year = parseInt(dateMatch[3], 10);
        const date = new Date(year, month, day);

        // Find the next line that starts with a number (value)
        let value = null;
        for (let j = i + 1; j < lines.length; j++) {
          if (dateRegex.test(lines[j])) {
            break;
          }
          const vMatch = lines[j].match(valueRegex);
          if (vMatch) {
            value = parseFloat(vMatch[1]);
            break;
          }
        }

        if (value !== null && !isNaN(value)) {
          dataPoints.push({ date, value });
        }
      }

      if (dataPoints.length === 0) {
        return null;
      }

      // Sort by date
      dataPoints.sort((a, b) => a.date - b.date);

      return { dataPoints, refLow, refHigh, labName };
    }

    function formatDate(date) {
      return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
    }

    function formatYear(date) {
      return date.getFullYear().toString();
    }

    function niceScale(min, max, ticks = 5) {
      const range = max - min;
      const roughStep = range / ticks;
      const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
      const residual = roughStep / magnitude;

      let niceStep;
      if (residual <= 1.5) niceStep = magnitude;
      else if (residual <= 3) niceStep = 2 * magnitude;
      else if (residual <= 7) niceStep = 5 * magnitude;
      else niceStep = 10 * magnitude;

      const niceMin = Math.floor(min / niceStep) * niceStep;
      const niceMax = Math.ceil(max / niceStep) * niceStep;

      const values = [];
      for (let v = niceMin; v <= niceMax + niceStep * 0.5; v += niceStep) {
        values.push(Math.round(v * 1000) / 1000);
      }

      return { min: niceMin, max: niceMax, values };
    }

    function linearRegression(dataPoints) {
      const n = dataPoints.length;
      if (n < 2) return null;

      // Use time in days from first point for x values
      const firstTime = dataPoints[0].date.getTime();
      const msPerDay = 24 * 60 * 60 * 1000;

      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

      for (const d of dataPoints) {
        const x = (d.date.getTime() - firstTime) / msPerDay;
        const y = d.value;
        sumX += x;
        sumY += y;
        sumXY += x * y;
        sumX2 += x * x;
      }

      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;

      return { slope, intercept, firstTime, msPerDay };
    }

    function getYearTicks(minDate, maxDate) {
      const ticks = [];
      const startYear = minDate.getFullYear();
      const endYear = maxDate.getFullYear();

      for (let year = startYear; year <= endYear + 1; year++) {
        const date = new Date(year, 0, 1);
        if (date >= minDate && date <= maxDate) {
          ticks.push(date);
        }
      }

      // Always include first and last year if they're not already there
      if (ticks.length === 0 || ticks[0].getFullYear() > startYear) {
        ticks.unshift(new Date(startYear, 0, 1));
      }
      if (ticks[ticks.length - 1].getFullYear() < endYear) {
        ticks.push(new Date(endYear, 0, 1));
      }

      return ticks;
    }

    function generateFormattedOutput(parsed) {
      if (!parsed) {
        outputArea.innerHTML = '<span style="color: #999;">No data to display</span>';
        return;
      }

      const { dataPoints, refLow, refHigh, labName } = parsed;

      // Generate output in reverse chronological order (most recent first)
      const sortedPoints = [...dataPoints].sort((a, b) => b.date - a.date);

      // Find max width for value column (including flag) for alignment
      const maxValueWidth = Math.max(...sortedPoints.map(d => {
        const isHigh = refHigh != null && d.value > refHigh;
        const isLow = refLow != null && d.value < refLow;
        const flag = isHigh ? ' (H)' : (isLow ? ' (L)' : '');
        return (d.value.toFixed(2) + flag).length;
      }));

      const header = labName || 'Lab Value';
      let html = `<strong>${header}:</strong>\n`;
      for (const d of sortedPoints) {
        const dateStr = formatDate(d.date);
        const isHigh = refHigh != null && d.value > refHigh;
        const isLow = refLow != null && d.value < refLow;

        const rawValue = d.value.toFixed(2);
        const flag = isHigh ? ' (H)' : (isLow ? ' (L)' : '');
        const paddedValue = (rawValue + flag).padEnd(maxValueWidth);

        let valueStr;
        if (isHigh) {
          valueStr = `<span class="high">${paddedValue}</span>`;
        } else if (isLow) {
          valueStr = `<span class="low">${paddedValue}</span>`;
        } else {
          valueStr = paddedValue;
        }

        html += `  ${valueStr} @ ${dateStr}\n`;
      }

      outputArea.innerHTML = html;
    }

    function renderChart(parsed) {
      // Update formatted output
      generateFormattedOutput(parsed);

      if (!parsed) {
        statusEl.textContent = 'No valid data found.';
        chartContainer.innerHTML = '';
        legend.style.display = 'none';
        trendInfo.style.display = 'none';
        return;
      }

      const { dataPoints, refLow, refHigh, labName } = parsed;
      const displayName = labName || 'Lab Value';

      statusEl.textContent = `Parsed ${dataPoints.length} data point(s)` +
        (refHigh != null ? ` | Ref range: ${refLow}–${refHigh}` : '');

      legend.style.display = 'flex';
      legendLabel.textContent = displayName;
      refLegend.style.display = refHigh != null ? 'flex' : 'none';
      trendLegend.style.display = dataPoints.length >= 2 ? 'flex' : 'none';

      // Get container dimensions
      const rect = chartContainer.getBoundingClientRect();
      const width = rect.width || 600;
      const height = rect.height || 400;
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      // Calculate scales
      const minDate = dataPoints[0].date;
      const maxDate = dataPoints[dataPoints.length - 1].date;
      const dateRange = maxDate - minDate;
      const datePadding = dateRange * 0.05;

      const minTime = minDate.getTime() - datePadding;
      const maxTime = maxDate.getTime() + datePadding;

      let minValue = Math.min(...dataPoints.map(d => d.value));
      let maxValue = Math.max(...dataPoints.map(d => d.value));

      if (refHigh != null) {
        maxValue = Math.max(maxValue, refHigh);
        minValue = Math.min(minValue, refLow);
      }

      const yScale = niceScale(minValue * 0.9, maxValue * 1.1, 6);

      // Scale functions
      const xScale = (date) => {
        const t = date.getTime();
        return margin.left + ((t - minTime) / (maxTime - minTime)) * innerWidth;
      };

      const yScaleFn = (value) => {
        return margin.top + innerHeight - ((value - yScale.min) / (yScale.max - yScale.min)) * innerHeight;
      };

      // Build SVG
      let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;

      // Y-axis grid lines and labels
      for (const v of yScale.values) {
        const y = yScaleFn(v);
        svg += `<line class="grid-line" x1="${margin.left}" y1="${y}" x2="${width - margin.right}" y2="${y}" />`;
        svg += `<text class="axis-label" x="${margin.left - 10}" y="${y + 4}" text-anchor="end">${v.toFixed(2)}</text>`;
      }

      // X-axis grid lines and labels (years)
      const yearTicks = getYearTicks(new Date(minTime), new Date(maxTime));
      for (const date of yearTicks) {
        const x = xScale(date);
        if (x >= margin.left && x <= width - margin.right) {
          svg += `<line class="grid-line" x1="${x}" y1="${margin.top}" x2="${x}" y2="${height - margin.bottom}" />`;
          svg += `<text class="axis-label" x="${x}" y="${height - margin.bottom + 20}" text-anchor="middle">${formatYear(date)}</text>`;
        }
      }

      // Axis lines
      svg += `<line stroke="#333" stroke-width="1" x1="${margin.left}" y1="${height - margin.bottom}" x2="${width - margin.right}" y2="${height - margin.bottom}" />`;
      svg += `<line stroke="#333" stroke-width="1" x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${height - margin.bottom}" />`;

      // Axis titles
      svg += `<text class="axis-title" x="${width / 2}" y="${height - 5}" text-anchor="middle">Date</text>`;
      svg += `<text class="axis-title" x="${15}" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 15, ${height / 2})">${displayName}</text>`;

      // Reference lines (upper and lower)
      if (refHigh != null) {
        const refYHigh = yScaleFn(refHigh);
        svg += `<line class="ref-line" x1="${margin.left}" y1="${refYHigh}" x2="${width - margin.right}" y2="${refYHigh}" />`;
      }
      if (refLow != null) {
        const refYLow = yScaleFn(refLow);
        svg += `<line class="ref-line" x1="${margin.left}" y1="${refYLow}" x2="${width - margin.right}" y2="${refYLow}" />`;
      }

      // Linear regression line
      const regression = linearRegression(dataPoints);
      if (regression) {
        const { slope, intercept, firstTime, msPerDay } = regression;

        // Calculate y values at the start and end of the x-axis
        const x1Days = (minTime - firstTime) / msPerDay;
        const x2Days = (maxTime - firstTime) / msPerDay;
        const y1Value = intercept + slope * x1Days;
        const y2Value = intercept + slope * x2Days;

        const lineX1 = margin.left;
        const lineX2 = width - margin.right;
        const lineY1 = yScaleFn(y1Value);
        const lineY2 = yScaleFn(y2Value);

        svg += `<line class="trend-line" x1="${lineX1}" y1="${lineY1}" x2="${lineX2}" y2="${lineY2}" />`;

        // Display slope info with appropriate time unit based on data span
        const dataSpanDays = (maxDate - minDate) / msPerDay;
        let slopeValue, timeUnit;

        if (dataSpanDays < 60) {
          // Less than 2 months: show per day
          slopeValue = slope;
          timeUnit = 'day';
        } else if (dataSpanDays < 365) {
          // Less than 1 year: show per month
          slopeValue = slope * 30.44; // average days per month
          timeUnit = 'month';
        } else {
          // 1 year or more: show per year
          slopeValue = slope * 365.25;
          timeUnit = 'year';
        }

        const slopeSign = slopeValue >= 0 ? '+' : '';
        trendInfo.textContent = `Linear Regression Slope: ${slopeSign}${slopeValue.toFixed(3)} mg/dL per ${timeUnit}`;
        trendInfo.style.display = 'block';
      } else {
        trendInfo.style.display = 'none';
      }

      // Data line
      if (dataPoints.length > 1) {
        let pathD = `M ${xScale(dataPoints[0].date)} ${yScaleFn(dataPoints[0].value)}`;
        for (let i = 1; i < dataPoints.length; i++) {
          pathD += ` L ${xScale(dataPoints[i].date)} ${yScaleFn(dataPoints[i].value)}`;
        }
        svg += `<path class="data-line" d="${pathD}" />`;
      }

      // Data points
      for (let i = 0; i < dataPoints.length; i++) {
        const d = dataPoints[i];
        const x = xScale(d.date);
        const y = yScaleFn(d.value);
        const isOutOfRange = (refHigh != null && d.value > refHigh) || (refLow != null && d.value < refLow);
        const pointClass = isOutOfRange ? 'data-point out-of-range' : 'data-point';
        svg += `<circle class="${pointClass}" cx="${x}" cy="${y}" r="4" data-index="${i}" />`;
      }

      svg += '</svg>';
      chartContainer.innerHTML = svg;

      // Add hover interactions
      const points = chartContainer.querySelectorAll('.data-point');
      points.forEach(point => {
        point.addEventListener('mouseenter', (e) => {
          const idx = parseInt(point.getAttribute('data-index'), 10);
          const d = dataPoints[idx];
          tooltip.textContent = `${formatDate(d.date)}: ${d.value.toFixed(2)} mg/dL`;
          tooltip.style.display = 'block';
        });

        point.addEventListener('mousemove', (e) => {
          tooltip.style.left = (e.pageX + 10) + 'px';
          tooltip.style.top = (e.pageY - 30) + 'px';
        });

        point.addEventListener('mouseleave', () => {
          tooltip.style.display = 'none';
        });
      });
    }

    // Handle resize
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        const parsed = parseData(textarea.value);
        renderChart(parsed);
      }, 100);
    });

    // Debounce input
    let debounceTimer = null;
    textarea.addEventListener('input', () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const parsed = parseData(textarea.value);
        renderChart(parsed);
      }, 300);
    });

    // Preload example data
    textarea.value = `CREATININE
Latest Ref Rng
0.70 - 1.30 mg/dL
8/21/2018
0.89
9/17/2018
1.09
10/2/2018
0.98
10/9/2018
1.04
11/5/2018
0.93
11/20/2018
0.93
4/24/2019
1.18
6/11/2019
1.05
8/12/2019
1.35 (H)
12/10/2019
1.11
2/20/2020
1.51 (H)
8/31/2020
0.98
1/6/2021
1.23
8/18/2021
1.21
2/16/2022
1.33 (H)
3/6/2023
1.24
8/6/2023
1.67 (H)
8/16/2023
1.39 (H)
1/30/2024
1.55 (H)
5/29/2024
1.69 (H)
8/29/2024
1.59 (H)
10/13/2025
1.98 (H)
11/24/2025
1.65 (H)

Legend:
(H) High`;

    // Initial render (slight delay to ensure container has dimensions)
    setTimeout(() => {
      const parsed = parseData(textarea.value);
      renderChart(parsed);
    }, 50);
  </script>
</body>
</html>
