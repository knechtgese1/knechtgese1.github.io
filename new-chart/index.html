<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lab Value Grapher</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: rgb(255, 251, 240); /* CPRS-ish */
      height: 100vh;
      overflow: hidden;
    }

    /* CPRS-style app frame */
    .app-frame {
      width: 870px;
      height: calc(100vh - 20px);
      margin: 10px auto;
      border-radius: 5px;
      border-width: 1px 2px 2px 1px;
      border-style: solid;
      border-color: rgb(221, 221, 221) rgb(153, 153, 153) rgb(153, 153, 153) rgb(221, 221, 221);
      background-color: rgb(240, 240, 240);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-sizing: border-box;
    }

    .titlebar {
      height: 22px;
      line-height: 22px;
      padding: 0 10px;
      font-size: 11px;
      font-weight: bold;
      color: black;
      border-bottom: 1px solid white;
      background: linear-gradient(rgb(152,180,208),rgb(185,209,234));
      flex: 0 0 auto;
      user-select: none;
    }

    .tabbar {
      display: flex;
      gap: 6px;
      padding: 6px 8px;
      border-bottom: 1px solid #ccc;
      background: #f2f2f2;
      flex: 0 0 auto;
    }

    .tabbar button {
      padding: 4px 10px;
      font-size: 12px;
      border: 1px solid #999;
      background: #e6e6e6;
      border-radius: 3px;
      cursor: pointer;
    }

    .tabbar button.active {
      background: white;
      border-color: #777;
    }

    .container {
      display: flex;
      flex: 1;
      min-height: 0;
    }
    .left, .right {
      padding: 12px;
      box-sizing: border-box;
    }
    .left {
      width: 40%;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
    }
    .input-section, .output-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .input-section {
      border-bottom: 1px solid #ccc;
      padding-bottom: 8px;
    }
    .output-section {
      padding-top: 8px;
    }
    .input-section h4, .output-section h4 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }
    .input-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .input-header h4 {
      margin: 0;
    }
    .input-buttons {
      display: flex;
      gap: 6px;
    }
    .clear-btn {
      padding: 4px 12px;
      font-size: 12px;
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .clear-btn:hover {
      background-color: #c82333;
    }
    .paste-btn {
      padding: 4px 12px;
      font-size: 12px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .paste-btn:hover {
      background-color: #0056b3;
    }
    textarea {
      flex: 1;
      width: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 8px;
      box-sizing: border-box;
    }
    #outputArea {
      flex: 1;
      width: 100%;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
      padding: 8px;
      background: #f9f9f9;
      border: 1px solid #ccc;
      box-sizing: border-box;
      white-space: pre-wrap;
      line-height: 1.4;
    }
    #outputArea .high {
      color: red;
      font-weight: bold;
    }
    #outputArea .low {
      color: blue;
      font-weight: bold;
    }
    #outputArea.plain-text-mode {
      background: #ffffff;
      border: 2px solid #777;
      line-height: 1.3;
      overflow-x: hidden; /* plain text chunks are width-capped; avoid accidental sideways scroll */
    }
    .plain-text-section {
      margin-bottom: 16px;
      position: relative;
    }
    .plain-text-header {
      position: relative;
      margin-bottom: 4px;
      text-align: right;
    }
    .plain-text-copy-btn {
      padding: 2px 8px;
      font-size: 10px;
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .plain-text-copy-btn:hover {
      background-color: #5a6268;
    }
    .plain-text-content {
      white-space: pre;
    }
    .right {
      width: 60%;
      display: flex;
      flex-direction: column;
    }

    /* Tabs: Output (formatter-first) vs Graph */
    body.mode-output .left {
      width: 70%;
      border-right: 1px solid #ccc;
    }
    body.mode-output .right {
      width: 30%;
      display: flex;
    }

    /* In Formatter tab, keep the column checklist visible but hide the graph UI */
    body.mode-output #chartContainer,
    body.mode-output .legend,
    body.mode-output #trendInfo,
    body.mode-output #tooltip,
    body.mode-output #status,
    body.mode-output .right h3 {
      display: none !important;
    }

    body.mode-graph .right {
      display: flex;
    }
    body.mode-graph .left {
      width: 40%;
      border-right: 1px solid #ccc;
    }
    #status {
      font-size: 12px;
      color: #666;
      margin-bottom: 4px;
    }
    #chartContainer {
      flex: 1;
      min-height: 0;
    }
    #chartContainer svg {
      width: 100%;
      height: 100%;
    }
    .axis-label {
      font-size: 12px;
      fill: #666;
    }
    .axis-title {
      font-size: 12px;
      fill: #333;
    }
    .grid-line {
      stroke: #e0e0e0;
      stroke-width: 1;
    }
    .data-line {
      fill: none;
      stroke: #36a2eb;
      stroke-width: 2;
    }
    .data-point {
      fill: #36a2eb;
      cursor: pointer;
    }
    .data-point.out-of-range {
      fill: #ff4444;
    }
    .data-point:hover {
      fill: #1a7fc4;
      r: 6;
    }
    .data-point.out-of-range:hover {
      fill: #cc0000;
    }
    .ref-line {
      stroke: #ff6384;
      stroke-width: 1.5;
      stroke-dasharray: 5, 5;
    }
    .trend-line {
      stroke: #4caf50;
      stroke-width: 1.5;
      stroke-dasharray: 4, 4;
    }
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      z-index: 100;
    }
    .legend {
      display: flex;
      gap: 20px;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-line {
      width: 20px;
      height: 2px;
      background: #36a2eb;
    }
    .legend-line.ref {
      background: #ff6384;
      background: repeating-linear-gradient(
        90deg,
        #ff6384 0px,
        #ff6384 5px,
        transparent 5px,
        transparent 10px
      );
    }
    .column-selector {
      margin-bottom: 12px;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
      display: none;
    }
    .column-selector h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
    }
    .column-group {
      margin-bottom: 8px;
    }
    .column-group-title {
      font-weight: bold;
      font-size: 12px;
      margin-bottom: 4px;
      color: #555;
    }
    .column-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    .column-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
    }
    .column-checkbox input[type="checkbox"] {
      cursor: pointer;
    }
    .column-checkbox label {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: opacity 0.2s;
    }
    .column-checkbox label:hover {
      opacity: 1 !important;
    }
    .color-indicator {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      display: inline-block;
    }
    .series-dimmed {
      opacity: 0.15 !important;
      transition: opacity 0.2s;
    }
    .series-highlighted {
      opacity: 1 !important;
      transition: opacity 0.2s;
    }
    .series-controls {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #ddd;
    }
    .series-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 11px;
    }
    .output-table {
      margin-bottom: 16px;
    }
    .output-table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .output-table h5 {
      margin: 0;
      font-size: 13px;
      font-weight: bold;
      color: #333;
    }
    .output-table-copy-btn {
      padding: 2px 8px;
      font-size: 10px;
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .output-table-copy-btn:hover {
      background-color: #5a6268;
    }
    .output-table table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .output-table th {
      background: #e9e9e9;
      padding: 4px 6px;
      text-align: left;
      border: 1px solid #ccc;
    }
    .output-table td {
      padding: 3px 6px;
      border: 1px solid #ddd;
    }
    .date-range-controls {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .date-range-controls label {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .date-range-controls select {
      padding: 4px 8px;
      font-size: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
    }
  </style>
</head>
<body class="mode-output">
  <div class="app-frame">
    <div class="titlebar">CPRS Formatter 2.0</div>
    <div class="tabbar" role="tablist" aria-label="View">
      <button id="tabOutput" class="active" type="button" role="tab" aria-selected="true">Formatter</button>
      <button id="tabGraph" type="button" role="tab" aria-selected="false">Graph</button>
    </div>
    <div class="container">
    <div class="left">
      <div class="input-section">
        <div class="input-header">
          <h4>Paste Data Here</h4>
          <div class="input-buttons">
            <button class="paste-btn" id="pasteBtn">Paste from Clipboard</button>
            <button class="clear-btn" id="clearBtn">Clear</button>
          </div>
        </div>
        <textarea id="dataInput" placeholder="Paste your lab data here..."></textarea>
        <small>
          Supports both single-column and multi-column table formats.<br>
          Single: date on one line, value on next (e.g., 8/21/2018 then 0.89)<br>
          Table: header row, optional ref ranges, then date + values per row<br>
          <strong>Multiple tables:</strong> Paste multiple tables together - they'll be combined!<br>
          Extra text like &quot;(H)&quot;, &quot;(L)&quot;, and legends are ignored.
        </small>
      </div>
      <div class="output-section">
        <div class="input-header">
          <h4>Formatted Output</h4>
          <div class="input-buttons">
            <button class="paste-btn" id="toggleFormatBtn">Plain Text</button>
            <button class="paste-btn" id="copyOutputBtn">Copy All</button>
          </div>
        </div>
        <div id="outputArea"></div>
      </div>
    </div>
    <div class="right">
      <h3>Lab Values Over Time</h3>
      <div id="status">Waiting for dataâ€¦</div>
      <div class="column-selector" id="columnSelector"></div>
      <div class="legend" id="legend" style="display: none;">
        <div class="legend-item">
          <div class="legend-line"></div>
          <span id="legendLabel">Lab Value</span>
        </div>
        <div class="legend-item" id="refLegend" style="display: none;">
          <div class="legend-line ref"></div>
          <span>Ref Limits</span>
        </div>
        <div class="legend-item" id="trendLegend" style="display: none;">
          <div class="legend-line" style="background: repeating-linear-gradient(90deg, #4caf50 0px, #4caf50 4px, transparent 4px, transparent 8px);"></div>
          <span>Linear Regression</span>
        </div>
      </div>
      <div id="trendInfo" style="font-size: 12px; color: #666; margin-bottom: 4px; display: none;"></div>
      <div class="date-range-controls" id="dateRangeControls" style="display: none;">
        <div style="display:flex; gap:12px; align-items:center; margin-bottom:6px; flex-wrap:wrap;">
          <span style="font-weight:600;">Range:</span>
          <label style="display:flex; align-items:center; gap:6px;">
            <input type="radio" name="rangePreset" id="rangeWeek" value="week" />
            Week
          </label>
          <label style="display:flex; align-items:center; gap:6px;">
            <input type="radio" name="rangePreset" id="rangeAll" value="all" checked />
            All
          </label>
        </div>
        <label>
          Start date:
          <select id="startDateSelect"></select>
        </label>
        <label>
          End date:
          <select id="endDateSelect"></select>
        </label>
      </div>
      <div id="chartContainer"></div>
      <div class="tooltip" id="tooltip"></div>
    </div>
  </div>
  </div>

  <script>
    const textarea = document.getElementById('dataInput');
    const pasteBtn = document.getElementById('pasteBtn');
    const clearBtn = document.getElementById('clearBtn');
    const copyOutputBtn = document.getElementById('copyOutputBtn');
    const toggleFormatBtn = document.getElementById('toggleFormatBtn');
    const statusEl = document.getElementById('status');
    const chartContainer = document.getElementById('chartContainer');
    const tooltip = document.getElementById('tooltip');
    const legend = document.getElementById('legend');
    const refLegend = document.getElementById('refLegend');
    const trendLegend = document.getElementById('trendLegend');
    const trendInfo = document.getElementById('trendInfo');
    const outputArea = document.getElementById('outputArea');
    const legendLabel = document.getElementById('legendLabel');
    const dateRangeControls = document.getElementById('dateRangeControls');
    const rangeWeekRadio = document.getElementById('rangeWeek');
    const rangeAllRadio = document.getElementById('rangeAll');
    const startDateSelect = document.getElementById('startDateSelect');
    const endDateSelect = document.getElementById('endDateSelect');
    const columnSelector = document.getElementById('columnSelector');

    // Tabs (Formatter vs Graph)
    const tabOutput = document.getElementById('tabOutput');
    const tabGraph = document.getElementById('tabGraph');

    function setTab(mode) {
      document.body.classList.toggle('mode-output', mode === 'output');
      document.body.classList.toggle('mode-graph', mode === 'graph');

      tabOutput.classList.toggle('active', mode === 'output');
      tabGraph.classList.toggle('active', mode === 'graph');

      tabOutput.setAttribute('aria-selected', mode === 'output' ? 'true' : 'false');
      tabGraph.setAttribute('aria-selected', mode === 'graph' ? 'true' : 'false');

      // When switching to graph, re-render to ensure SVG sizes are correct.
      if (mode === 'graph') {
        setTimeout(() => renderChartFromParsedData(), 0);
      }
    }

    tabOutput.addEventListener('click', () => setTab('output'));
    tabGraph.addEventListener('click', () => setTab('graph'));

    // Output format state
    let isPlainTextFormat = false;

    // Date range preset (CPRS-Formatter uses Date.now()-7*msDay for "week")
    let rangePreset = 'all'; // 'all' | 'week'

    const msDay = 86400000;
    function isWithinPresetRange(date) {
      if (rangePreset !== 'week') return true;
      return date.getTime() > Date.now() - 7 * msDay;
    }

    function applyRangePresetToDropdowns() {
      if (!fullParsedData) return;

      // Determine the ordered list of available dates.
      let dates = [];
      if (fullParsedData.type === 'single' && fullParsedData.dateGroups) {
        dates = fullParsedData.dateGroups.map(g => g.date);
      } else if (fullParsedData.type === 'table') {
        dates = getAllDatesFromTableData(fullParsedData);
      }
      if (dates.length === 0) return;

      // Default: all
      if (rangePreset === 'all') {
        startDateSelect.value = '0';
        endDateSelect.value = (dates.length - 1).toString();
        validateAndApplyDateRange();
        return;
      }

      // Week: start at the earliest date that is within last 7 days.
      const threshold = Date.now() - 7 * msDay;
      let startIdx = 0;
      for (let i = 0; i < dates.length; i++) {
        if (dates[i].getTime() >= threshold) {
          startIdx = i;
          break;
        }
      }
      startDateSelect.value = startIdx.toString();
      endDateSelect.value = (dates.length - 1).toString();
      validateAndApplyDateRange();
    }

    // Chart margins
    const margin = { top: 20, right: 30, bottom: 50, left: 60 };

    // Store the full parsed data globally for filtering
    let fullParsedData = null;
    let selectedColumns = new Set();
    let columnColors = {};
    let seriesVisibility = {};
    let trendlineVisibility = {};

    // Color palette for multiple series
    const colorPalette = [
      '#36a2eb', '#ff6384', '#4bc0c0', '#ff9f40', '#9966ff',
      '#ffcd56', '#c9cbcf', '#4caf50', '#f44336', '#2196f3'
    ];

    // Lab test categorization (based on CPRS formatter)
    const labCategories = {
      'Chem': [
        'CREATININE', 'CREATININE-E', 'CREATININE,SERUM', 'CREATININE, SERUM',
        'SODIUM', 'POTASSIUM', 'CHLORIDE', 'CO2', 'CARBON DIOXIDE',
        'UREA NITROGEN', 'UREA NITROGEN, BLOOD', 'BUN',
        'CALCIUM', 'MAGNESIUM', 'MAG', 'PHOSPHORUS', 'PO4,SERUM', 'PHOS'
      ],
      'CBC': [
        'WBC', 'HEMOGLOBIN', 'HGB', 'HEMATOCRIT', 'HCT',
        'PLATELET', 'PLT', 'MCV'
      ],
      'Diff': [
        'ABSOLUTE NEUTROPHIL COUNT', 'ABSOLUTE GRANULOCYTES', 'ANC', 'PMN', 'NEUTROPHIL %',
        'ABSOLUTE LYMPHOCYTE COUNT', 'ABSOLUTE LYMPHOCYTES', 'ALC', 'LYMPH', 'LYMPHOCYTE %',
        'ABSOLUTE MONOCYTES', 'AMC', 'MONO', 'MONOCYTE %',
        'ABSOLUTE EOS.', 'AEC', 'EOS', 'EOSINOPHIL %', 'EOS %',
        'ABSOLUTE BASOPHILS', 'ABC', 'BASO', 'BASOPHIL %',
        'BANDS', 'PROMYELOCYTES', 'MYELOCYTES', 'METAMYELOCYTES', 'BLASTS'
      ],
      'Liver': [
        'AST', 'AST(SGOT)', 'SGOT',
        'ALT', 'ALT(SGPT)', 'SGPT',
        'ALKALINE PHOSPHATASE', 'ALP', 'ALK', 'ALK PHO',
        'BILIRUBIN, TOTAL', 'TOTAL BILIRUBIN', 'TOT. BILIRUBIN', 'TBIL',
        'DIRECT BILIRUBIN', 'DIR. BILIRUBIN', 'DBIL',
        'ALBUMIN', 'ALBUMIN,ELECT.',
        'PROTEIN, TOTAL', 'PROTEIN,SERUM', 'TOTAL PROTEIN,SERUM',
        'AMMONIA'
      ],
      'Coags': [
        'PT', 'INR', 'PTT', 'FIBRINOGEN', 'D-DIMER'
      ],
      'Cardiac': [
        'TROPONIN I', 'TROPONIN-I', 'TROP I',
        'CK-MB', 'MB-AG',
        'CREATINE KINASE', 'CK', 'CPK',
        'BNP'
      ],
      'Lipid-A1c': [
        'HEMOGLOBIN A1C', 'HGB A1C', 'A1C',
        'CHOLESTEROL', 'CHOL',
        'LDL', 'LDL CHOLESTEROL (CALC)', 'LDL,DIRECT',
        'HDL', 'HDL CHOLESTEROL',
        'TRIGLYCERIDE', 'TG',
        'VLDL'
      ],
      'Endocrine': [
        'TSH', 'T4,FREE', 'FREE T4', 'T-4', 'FREE T3',
        'PTH', 'PTH (INTACT)', 'PTH (INTACT)QUEST',
        'VITAMIN D,TOTAL(SCREEN)', 'VITAMIN D TOTAL(SCREEN)', 'TOTAL VIT D', 'VIT D 25-OH(WRJ)',
        'CORTISOL AM', 'CORTISOL PM', 'ACTH',
        'RENIN ACTIVITY', 'RENIN ACTIVITY(PRA)', 'RENIN ACTIVITY, PLASMA(PRA)',
        'ALDOSTERONE', 'ALDOSTERONE,PLASMA', 'ALDOSTERONE,SERUM'
      ],
      'Other': []
    };

    // Short headers for plain text output (matching CPRS formatter)
    const shortHeaders = {
      'CREATININE': 'Cr',
      'CREATININE-E': 'Cr',
      'CREATININE,SERUM': 'Cr',
      'CREATININE, SERUM': 'Cr',
      'SODIUM': 'Na',
      'POTASSIUM': 'K',
      'CHLORIDE': 'Cl',
      'CO2': 'CO2',
      'CARBON DIOXIDE': 'CO2',
      'UREA NITROGEN': 'BUN',
      'UREA NITROGEN, BLOOD': 'BUN',
      'BUN': 'BUN',
      'CALCIUM': 'Ca',
      'MAGNESIUM': 'Mg',
      'MAG': 'Mg',
      'PHOSPHORUS': 'PO4',
      'PO4,SERUM': 'PO4',
      'PHOS': 'PO4',
      'WBC': 'WBC',
      'HEMOGLOBIN': 'Hgb',
      'HGB': 'Hgb',
      'HEMATOCRIT': 'Hct',
      'HCT': 'Hct',
      'PLATELET': 'Plt',
      'PLT': 'Plt',
      'MCV': 'MCV',
      'ABSOLUTE NEUTROPHIL COUNT': 'PMN',
      'ABSOLUTE GRANULOCYTES': 'PMN',
      'ANC': 'PMN',
      'PMN': 'PMN',
      'NEUTROPHIL %': 'PMN',
      'ABSOLUTE LYMPHOCYTE COUNT': 'Lymph',
      'ABSOLUTE LYMPHOCYTES': 'Lymph',
      'ALC': 'Lymph',
      'LYMPH': 'Lymph',
      'LYMPHOCYTE %': 'Lymph',
      'ABSOLUTE MONOCYTES': 'Mono',
      'AMC': 'Mono',
      'MONO': 'Mono',
      'MONOCYTE %': 'Mono',
      'ABSOLUTE EOS.': 'Eos',
      'AEC': 'Eos',
      'EOS': 'Eos',
      'EOSINOPHIL %': 'Eos',
      'EOS %': 'Eos',
      'ABSOLUTE BASOPHILS': 'Baso',
      'ABC': 'Baso',
      'BASO': 'Baso',
      'BASOPHIL %': 'Baso',
      'BANDS': 'Bands',
      'AST': 'AST',
      'AST(SGOT)': 'AST',
      'SGOT': 'AST',
      'ALT': 'ALT',
      'ALT(SGPT)': 'ALT',
      'SGPT': 'ALT',
      'ALKALINE PHOSPHATASE': 'ALK',
      'ALP': 'ALK',
      'ALK': 'ALK',
      'ALK PHO': 'ALK',
      'BILIRUBIN, TOTAL': 'TBil',
      'TOTAL BILIRUBIN': 'TBil',
      'TOT. BILIRUBIN': 'TBil',
      'TBIL': 'TBil',
      'DIRECT BILIRUBIN': 'DBil',
      'DIR. BILIRUBIN': 'DBil',
      'DBIL': 'DBil',
      'ALBUMIN': 'Albumin',
      'ALBUMIN,ELECT.': 'Albumin',
      'PROTEIN, TOTAL': 'Protein',
      'PROTEIN,SERUM': 'Protein',
      'TOTAL PROTEIN,SERUM': 'Protein',
      'AMMONIA': 'Ammonia',
      'PT': 'PT',
      'INR': 'INR',
      'PTT': 'PTT',
      'FIBRINOGEN': 'Fibrinogen',
      'D-DIMER': 'D-dimer',
      'TROPONIN I': 'Trop I',
      'TROPONIN-I': 'Trop I',
      'TROP I': 'Trop I',
      'CK-MB': 'CK-MB',
      'MB-AG': 'CK-MB',
      'CREATINE KINASE': 'CK',
      'CK': 'CK',
      'CPK': 'CK',
      'BNP': 'BNP',
      'HEMOGLOBIN A1C': 'A1c',
      'HGB A1C': 'A1c',
      'A1C': 'A1c',
      'CHOLESTEROL': 'CHOL',
      'CHOL': 'CHOL',
      'LDL': 'LDL',
      'LDL CHOLESTEROL (CALC)': 'LDL',
      'LDL,DIRECT': 'LDL',
      'HDL': 'HDL',
      'HDL CHOLESTEROL': 'HDL',
      'TRIGLYCERIDE': 'TG',
      'TG': 'TG',
      'VLDL': 'VLDL'
    };

    function categorizeLabTest(testName) {
      const upperName = testName.toUpperCase();
      for (const [category, tests] of Object.entries(labCategories)) {
        if (category === 'Other') continue;
        for (const test of tests) {
          if (upperName === test || upperName.includes(test) || test.includes(upperName)) {
            return category;
          }
        }
      }
      return 'Other';
    }

    // Paste from clipboard button handler
    pasteBtn.addEventListener('click', async () => {
      try {
        const text = await navigator.clipboard.readText();
        textarea.value = text;
        const parsed = parseData(text);
        updateAndRenderChart(parsed);
      } catch (err) {
        alert('Failed to read clipboard. Please make sure you have granted clipboard permissions or use Ctrl+V / Cmd+V to paste manually.');
        console.error('Clipboard read error:', err);
      }
    });

    // Clear button handler
    clearBtn.addEventListener('click', () => {
      textarea.value = '';
      const parsed = parseData('');
      updateAndRenderChart(parsed);
    });

    // Copy output button handler
    copyOutputBtn.addEventListener('click', async () => {
      const outputContent = outputArea.innerHTML;

      if (!outputContent || outputContent.includes('No data to display')) {
        alert('No data to copy');
        return;
      }

      try {
        // Create both HTML and plain text versions
        const htmlContent = outputContent;

        // Create a temporary element to convert HTML to plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = outputContent;
        const plainText = tempDiv.innerText;

        // Use the Clipboard API to write both formats
        const clipboardItem = new ClipboardItem({
          'text/html': new Blob([htmlContent], { type: 'text/html' }),
          'text/plain': new Blob([plainText], { type: 'text/plain' })
        });

        await navigator.clipboard.write([clipboardItem]);

        // Visual feedback
        const originalText = copyOutputBtn.textContent;
        copyOutputBtn.textContent = 'Copied!';
        copyOutputBtn.style.backgroundColor = '#28a745';
        setTimeout(() => {
          copyOutputBtn.textContent = originalText;
          copyOutputBtn.style.backgroundColor = '';
        }, 1500);
      } catch (err) {
        console.error('Copy failed:', err);
        alert('Failed to copy to clipboard. Please select and copy manually (Ctrl+C / Cmd+C).');
      }
    });

    // Toggle format button handler
    toggleFormatBtn.addEventListener('click', () => {
      isPlainTextFormat = !isPlainTextFormat;
      toggleFormatBtn.textContent = isPlainTextFormat ? 'Table View' : 'Plain Text';

      // Regenerate output with current format
      generateFormattedOutput(fullParsedData);
    });

    function parseData(text) {
      const lines = text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length > 0);

      if (lines.length === 0) {
        return null;
      }

      // Detect if this is table format (multi-column) or single-column format
      // Table format will have tabs or multiple spaces separating values
      const isTableFormat = lines.some(line => {
        const parts = line.split(/\t|  +/);
        return parts.length > 2 && parts.filter(p => p.trim().length > 0).length > 2;
      });

      if (isTableFormat) {
        return parseTableData(lines);
      } else {
        return parseSingleColumnData(lines);
      }
    }

    function parseSingleColumnData(lines) {
      let refLow = null;
      let refHigh = null;
      let labName = null;

      // Try to detect lab name from the first non-empty line that's not a date or number
      const dateRegexCheck = /^\d{1,2}\/\d{1,2}\/\d{4}/;
      const numberRegexCheck = /^\d+(\.\d+)?/;
      const refRangeCheck = /^\s*\d+(\.\d+)?\s*-\s*\d+(\.\d+)?/;
      for (const line of lines) {
        if (!dateRegexCheck.test(line) && !numberRegexCheck.test(line) && !refRangeCheck.test(line) && !line.match(/^(Latest|Legend|High|\(H\)|\(L\))/i)) {
          labName = line;
          break;
        }
      }

      // Try to detect reference range like "0.70 - 1.30 mg/dL"
      for (const line of lines) {
        const m = line.match(/^\s*(\d+(\.\d+)?)\s*-\s*(\d+(\.\d+)?)/);
        if (m) {
          refLow = parseFloat(m[1]);
          refHigh = parseFloat(m[3]);
          break;
        }
      }

      const dateRegex = /^(\d{1,2})\/(\d{1,2})\/(\d{4})/;
      const valueRegex = /^(\d+(\.\d+)?)/;

      const dateGroups = [];

      for (let i = 0; i < lines.length; i++) {
        const dateMatch = lines[i].match(dateRegex);
        if (!dateMatch) continue;

        const month = parseInt(dateMatch[1], 10) - 1;
        const day = parseInt(dateMatch[2], 10);
        const year = parseInt(dateMatch[3], 10);
        const date = new Date(year, month, day);

        // Find ALL values that follow this date (before the next date)
        const values = [];
        for (let j = i + 1; j < lines.length; j++) {
          if (dateRegex.test(lines[j])) {
            break;
          }
          const vMatch = lines[j].match(valueRegex);
          if (vMatch) {
            const value = parseFloat(vMatch[1]);
            if (!isNaN(value)) {
              values.push(value);
            }
          }
        }

        if (values.length > 0) {
          dateGroups.push({ date, values });
        }
      }

      if (dateGroups.length === 0) {
        return null;
      }

      // Sort by date
      dateGroups.sort((a, b) => a.date - b.date);

      // Now space out multiple values on the same date
      const dataPoints = [];
      const msPerDay = 24 * 60 * 60 * 1000;

      for (const { date, values } of dateGroups) {
        const numValues = values.length;

        if (numValues === 1) {
          // Single value: use exact date
          dataPoints.push({ date, value: values[0] });
        } else {
          // Multiple values: space them equidistantly between this date and next calendar day
          for (let j = 0; j < numValues; j++) {
            const offset = (j / numValues) * msPerDay;
            const adjustedDate = new Date(date.getTime() + offset);
            dataPoints.push({ date: adjustedDate, value: values[j] });
          }
        }
      }

      return {
        type: 'single',
        dataPoints,
        dateGroups,
        refLow,
        refHigh,
        labName,
        columns: labName ? [{ name: labName, refLow, refHigh }] : []
      };
    }

    function parseTableData(lines) {
      // Parse table format - can handle multiple tables in one paste
      const dateRegex = /^(\d{1,2})\/(\d{1,2})\/(\d{4})/;
      const allColumns = [];
      const allSeriesData = {}; // { columnName: [{ date, value }, ...] }

      let i = 0;
      while (i < lines.length) {
        // Skip empty lines
        if (lines[i].trim().length === 0) {
          i++;
          continue;
        }

        const parts = lines[i].split(/\t|  +/).map(p => p.trim()).filter(p => p.length > 0);

        // Check if this is a header line (non-date, non-number, multiple columns)
        if (parts.length > 1 && !dateRegex.test(parts[0]) && isNaN(parseFloat(parts[0]))) {
          let headerLine = null;
          let refRangeLine = null;
          let dataStartIndex = i + 1;

          if (parts[0].toLowerCase().includes('latest') || parts[0].toLowerCase().includes('ref')) {
            // This is the "Latest Ref Rng" line
            refRangeLine = lines[i];
            i++;
            continue;
          } else {
            // This is a header line
            headerLine = lines[i];

            // Check if next line is "Latest Ref Rng"
            if (i + 1 < lines.length) {
              const nextParts = lines[i + 1].split(/\t|  +/).map(p => p.trim()).filter(p => p.length > 0);
              if (nextParts[0] && (nextParts[0].toLowerCase().includes('latest') || nextParts[0].toLowerCase().includes('ref'))) {
                refRangeLine = lines[i + 1];
                dataStartIndex = i + 2;
              }
            }
          }

          if (!headerLine) {
            i++;
            continue;
          }

          // Parse this table
          const headerParts = headerLine.split(/\t|  +/).map(p => p.trim()).filter(p => p.length > 0);
          const columnNames = headerParts;

          // Parse reference ranges
          let refRanges = [];
          if (refRangeLine) {
            const refParts = refRangeLine.split(/\t|  +/).map(p => p.trim()).filter(p => p.length > 0);
            refRanges = refParts.map(part => {
              const match = part.match(/(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)/);
              if (match) {
                return { low: parseFloat(match[1]), high: parseFloat(match[2]) };
              }
              return null;
            });
          }

          // Initialize columns for this table
          const tableColumns = [];
          for (let colIdx = 0; colIdx < columnNames.length; colIdx++) {
            let colName = columnNames[colIdx];

            // Handle duplicate column names by appending a number
            let uniqueName = colName;
            let suffix = 2;
            while (allSeriesData[uniqueName]) {
              uniqueName = `${colName} (${suffix})`;
              suffix++;
            }

            const refRangeIndex = refRanges.length > columnNames.length ? colIdx + 1 : colIdx;
            const refRange = refRanges[refRangeIndex] || null;

            const col = {
              name: uniqueName,
              refLow: refRange ? refRange.low : null,
              refHigh: refRange ? refRange.high : null,
              category: categorizeLabTest(colName)
            };

            tableColumns.push(col);
            allColumns.push(col);
            allSeriesData[uniqueName] = [];
          }

          // Parse data rows for this table
          for (let dataIdx = dataStartIndex; dataIdx < lines.length; dataIdx++) {
            const dataParts = lines[dataIdx].split(/\t|  +/).map(p => p.trim()).filter(p => p.length > 0);
            if (dataParts.length === 0) continue;

            // Stop if we hit another header line
            if (dataParts.length > 1 && !dateRegex.test(dataParts[0]) && isNaN(parseFloat(dataParts[0]))) {
              break;
            }

            const dateMatch = dataParts[0].match(dateRegex);
            if (!dateMatch) continue;

            const month = parseInt(dateMatch[1], 10) - 1;
            const day = parseInt(dateMatch[2], 10);
            const year = parseInt(dateMatch[3], 10);
            const date = new Date(year, month, day);

            // Parse values for each column in this table
            for (let j = 1; j < dataParts.length && j - 1 < tableColumns.length; j++) {
              const valueStr = dataParts[j].replace(/\(H\)|\(L\)/g, '').trim();
              const value = parseFloat(valueStr);
              if (!isNaN(value)) {
                const colName = tableColumns[j - 1].name;
                allSeriesData[colName].push({ date, value });
              }
            }
          }

          i = dataStartIndex;
        } else {
          i++;
        }
      }

      if (allColumns.length === 0) {
        return null;
      }

      // Remove columns with no data
      const validColumns = allColumns.filter(col => allSeriesData[col.name].length > 0);

      return {
        type: 'table',
        columns: validColumns,
        seriesData: allSeriesData
      };
    }

    function formatDate(date) {
      return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
    }

    function formatYear(date) {
      return date.getFullYear().toString();
    }

    function populateDateDropdowns(dateGroups) {
      // Get unique dates from the original date groups (not the spaced-out dataPoints)
      const uniqueDates = dateGroups.map(g => g.date);

      // Clear existing options
      startDateSelect.innerHTML = '';
      endDateSelect.innerHTML = '';

      // Populate both dropdowns with the same dates
      uniqueDates.forEach((date, index) => {
        const dateStr = formatDate(date);
        const startOption = document.createElement('option');
        startOption.value = index;
        startOption.textContent = dateStr;
        startDateSelect.appendChild(startOption);

        const endOption = document.createElement('option');
        endOption.value = index;
        endOption.textContent = dateStr;
        endDateSelect.appendChild(endOption);
      });

      // Reset to show full date range (earliest to latest)
      // This happens automatically whenever new data is pasted
      startDateSelect.value = '0';
      endDateSelect.value = (uniqueDates.length - 1).toString();

      // Reset preset to All when new data arrives
      rangePreset = 'all';
      if (rangeAllRadio) rangeAllRadio.checked = true;
    }

    function validateAndApplyDateRange() {
      if (!fullParsedData) return;

      const startIdx = parseInt(startDateSelect.value, 10);
      const endIdx = parseInt(endDateSelect.value, 10);

      if (fullParsedData.type === 'single') {
        // Single column mode
        if (!fullParsedData.dateGroups) return;
        const maxIdx = fullParsedData.dateGroups.length - 1;

        // If start > end, snap end to last date
        if (startIdx > endIdx) {
          endDateSelect.value = maxIdx.toString();
        }
        // If end < start, snap start to first date
        else if (endIdx < startIdx) {
          startDateSelect.value = '0';
        }

        // Re-render chart with filtered data
        renderChartWithDateRange();
      } else if (fullParsedData.type === 'table') {
        // Multi-column mode
        const allDates = getAllDatesFromTableData(fullParsedData);
        const maxIdx = allDates.length - 1;

        // If start > end, snap end to last date
        if (startIdx > endIdx) {
          endDateSelect.value = maxIdx.toString();
        }
        // If end < start, snap start to first date
        else if (endIdx < startIdx) {
          startDateSelect.value = '0';
        }

        // Re-render chart with filtered data
        renderChartFromParsedData();
      }
    }

    // Event listeners for date range dropdowns
    startDateSelect.addEventListener('change', () => {
      // If user manually adjusts dropdowns, switch preset to "all" to match intent.
      rangePreset = 'all';
      rangeAllRadio.checked = true;
      validateAndApplyDateRange();
    });
    endDateSelect.addEventListener('change', () => {
      rangePreset = 'all';
      rangeAllRadio.checked = true;
      validateAndApplyDateRange();
    });

    // Preset radios (CPRS-Formatter behavior is relative to Date.now())
    rangeWeekRadio.addEventListener('change', () => {
      if (rangeWeekRadio.checked) {
        rangePreset = 'week';
        applyRangePresetToDropdowns();
      }
    });
    rangeAllRadio.addEventListener('change', () => {
      if (rangeAllRadio.checked) {
        rangePreset = 'all';
        applyRangePresetToDropdowns();
      }
    });

    function niceScale(min, max, ticks = 5) {
      const range = max - min;
      const roughStep = range / ticks;
      const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
      const residual = roughStep / magnitude;

      let niceStep;
      if (residual <= 1.5) niceStep = magnitude;
      else if (residual <= 3) niceStep = 2 * magnitude;
      else if (residual <= 7) niceStep = 5 * magnitude;
      else niceStep = 10 * magnitude;

      const niceMin = Math.floor(min / niceStep) * niceStep;
      const niceMax = Math.ceil(max / niceStep) * niceStep;

      const values = [];
      for (let v = niceMin; v <= niceMax + niceStep * 0.5; v += niceStep) {
        values.push(Math.round(v * 1000) / 1000);
      }

      return { min: niceMin, max: niceMax, values };
    }

    function linearRegression(dataPoints) {
      const n = dataPoints.length;
      if (n < 2) return null;

      // Use time in days from first point for x values
      const firstTime = dataPoints[0].date.getTime();
      const msPerDay = 24 * 60 * 60 * 1000;

      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

      for (const d of dataPoints) {
        const x = (d.date.getTime() - firstTime) / msPerDay;
        const y = d.value;
        sumX += x;
        sumY += y;
        sumXY += x * y;
        sumX2 += x * x;
      }

      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;

      return { slope, intercept, firstTime, msPerDay };
    }

    function getYearTicks(minDate, maxDate) {
      const ticks = [];
      const startYear = minDate.getFullYear();
      const endYear = maxDate.getFullYear();

      for (let year = startYear; year <= endYear + 1; year++) {
        const date = new Date(year, 0, 1);
        if (date >= minDate && date <= maxDate) {
          ticks.push(date);
        }
      }

      // Always include first and last year if they're not already there
      if (ticks.length === 0 || ticks[0].getFullYear() > startYear) {
        ticks.unshift(new Date(startYear, 0, 1));
      }
      if (ticks[ticks.length - 1].getFullYear() < endYear) {
        ticks.push(new Date(endYear, 0, 1));
      }

      return ticks;
    }

    function renderColumnSelector(parsed) {
      if (!parsed || parsed.type !== 'table') {
        columnSelector.style.display = 'none';
        return;
      }

      columnSelector.style.display = 'block';

      // Group columns by category
      const categorized = {};
      for (const col of parsed.columns) {
        const cat = col.category || 'Other';
        if (!categorized[cat]) categorized[cat] = [];
        categorized[cat].push(col);
      }

      // Assign colors
      let colorIndex = 0;
      for (const col of parsed.columns) {
        if (!columnColors[col.name]) {
          columnColors[col.name] = colorPalette[colorIndex % colorPalette.length];
          colorIndex++;
        }
        if (!(col.name in seriesVisibility)) {
          seriesVisibility[col.name] = true;
          selectedColumns.add(col.name);
        }
        if (!(col.name in trendlineVisibility)) {
          trendlineVisibility[col.name] = true;
        }
      }

      let html = '<h4>Select Columns to Display</h4>';

      // Order categories to match CPRS formatter
      const categoryOrder = ['Chem', 'CBC', 'Diff', 'Cardiac', 'Liver', 'Coags', 'Lipid-A1c', 'Endocrine', 'Other'];
      const sortedCategories = categoryOrder.filter(cat => categorized[cat]);

      for (const category of sortedCategories) {
        if (categorized[category].length === 0) continue;

        html += `<div class="column-group">`;
        html += `<div class="column-group-title">${category}</div>`;
        html += `<div class="column-checkboxes">`;

        for (const col of categorized[category]) {
          const checked = seriesVisibility[col.name] ? 'checked' : '';
          const color = columnColors[col.name];
          html += `
            <div class="column-checkbox">
              <label data-series-name="${col.name}">
                <input type="checkbox" ${checked} onchange="toggleColumn('${col.name}')" />
                <span class="color-indicator" style="background:${color}"></span>
                ${col.name}
              </label>
            </div>`;
        }

        html += `</div>`;
        html += `</div>`;
      }

      columnSelector.innerHTML = html;

      // Add hover listeners to column labels
      const labels = columnSelector.querySelectorAll('label[data-series-name]');
      labels.forEach(label => {
        label.addEventListener('mouseenter', () => {
          const seriesName = label.getAttribute('data-series-name');
          highlightSeries(seriesName);
        });

        label.addEventListener('mouseleave', () => {
          unhighlightAllSeries();
        });
      });
    }

    function highlightSeries(seriesName) {
      // Dim all labels except the hovered one
      const allLabels = columnSelector.querySelectorAll('label[data-series-name]');
      allLabels.forEach(label => {
        if (label.getAttribute('data-series-name') !== seriesName) {
          label.style.opacity = '0.3';
        }
      });

      // Dim all graph elements except the hovered series
      const allPaths = chartContainer.querySelectorAll('path[data-series]');
      const allCircles = chartContainer.querySelectorAll('circle[data-series]');

      allPaths.forEach(path => {
        if (path.getAttribute('data-series') !== seriesName) {
          path.classList.add('series-dimmed');
        } else {
          path.classList.add('series-highlighted');
        }
      });

      allCircles.forEach(circle => {
        if (circle.getAttribute('data-series') !== seriesName) {
          circle.classList.add('series-dimmed');
        } else {
          circle.classList.add('series-highlighted');
        }
      });
    }

    function unhighlightAllSeries() {
      // Restore all labels
      const allLabels = columnSelector.querySelectorAll('label[data-series-name]');
      allLabels.forEach(label => {
        label.style.opacity = '';
      });

      // Restore all graph elements
      const allPaths = chartContainer.querySelectorAll('path[data-series]');
      const allCircles = chartContainer.querySelectorAll('circle[data-series]');

      allPaths.forEach(path => {
        path.classList.remove('series-dimmed', 'series-highlighted');
      });

      allCircles.forEach(circle => {
        circle.classList.remove('series-dimmed', 'series-highlighted');
      });
    }

    window.toggleColumn = function(columnName) {
      if (seriesVisibility[columnName]) {
        seriesVisibility[columnName] = false;
        selectedColumns.delete(columnName);
      } else {
        seriesVisibility[columnName] = true;
        selectedColumns.add(columnName);
      }
      renderChartFromParsedData();
    };

    window.copyTableCategory = async function(category) {
      // Find the table element for this category
      const tableDiv = document.querySelector(`.output-table[data-category="${category}"]`);
      if (!tableDiv) return;

      const tableElement = tableDiv.querySelector('table');
      if (!tableElement) return;

      try {
        // Create HTML content (just the table with header)
        const categoryHeader = `<h5>${category}</h5>`;
        const htmlContent = categoryHeader + tableElement.outerHTML;

        // Create plain text version
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlContent;
        const plainText = tempDiv.innerText;

        // Copy to clipboard
        const clipboardItem = new ClipboardItem({
          'text/html': new Blob([htmlContent], { type: 'text/html' }),
          'text/plain': new Blob([plainText], { type: 'text/plain' })
        });

        await navigator.clipboard.write([clipboardItem]);

        // Visual feedback - find the button that was clicked
        const button = tableDiv.querySelector('.output-table-copy-btn');
        if (button) {
          const originalText = button.textContent;
          const originalColor = button.style.backgroundColor;
          button.textContent = 'Copied!';
          button.style.backgroundColor = '#28a745';
          setTimeout(() => {
            button.textContent = originalText;
            button.style.backgroundColor = originalColor;
          }, 1500);
        }
      } catch (err) {
        console.error('Copy failed:', err);
        alert('Failed to copy table. Please select and copy manually.');
      }
    };

    window.copyPlainTextCategory = async function(category) {
      // Find the plain text section for this category
      const section = document.querySelector(`.plain-text-section[data-category="${category}"]`);
      if (!section) return;

      const contentDiv = section.querySelector('.plain-text-content');
      if (!contentDiv) return;

      try {
        // Get the plain text from the data attribute
        const plainText = decodeURIComponent(contentDiv.getAttribute('data-plain-text'));

        // Copy as plain text only
        await navigator.clipboard.writeText(plainText);

        // Visual feedback
        const button = section.querySelector('.plain-text-copy-btn');
        if (button) {
          const originalText = button.textContent;
          const originalColor = button.style.backgroundColor;
          button.textContent = 'Copied!';
          button.style.backgroundColor = '#28a745';
          setTimeout(() => {
            button.textContent = originalText;
            button.style.backgroundColor = originalColor;
          }, 1500);
        }
      } catch (err) {
        console.error('Copy failed:', err);
        alert('Failed to copy text. Please select and copy manually.');
      }
    };

    function generateCategorizedOutput(parsed) {
      if (!parsed || parsed.type !== 'table') {
        return null;
      }

      // Group columns by category
      const categorized = {};
      for (const col of parsed.columns) {
        const cat = col.category || 'Other';
        if (!categorized[cat]) categorized[cat] = [];
        categorized[cat].push(col);
      }

      let html = '';

      // Order categories to match CPRS formatter
      const categoryOrder = ['Chem', 'CBC', 'Diff', 'Cardiac', 'Liver', 'Coags', 'Lipid-A1c', 'Endocrine', 'Other'];
      const sortedCategories = categoryOrder.filter(cat => categorized[cat]);

      for (const category of sortedCategories) {
        if (categorized[category].length === 0) continue;

        // Respect the column selections (checkboxes) for the text output too.
        const cols = categorized[category].filter(c => selectedColumns.has(c.name));
        if (cols.length === 0) continue;

        // Get all unique dates across all columns in this category
        const allDates = new Set();
        for (const col of cols) {
          for (const dataPoint of parsed.seriesData[col.name]) {
            allDates.add(dataPoint.date.getTime());
          }
        }
        const sortedDates = Array.from(allDates).map(t => new Date(t)).sort((a, b) => b - a);

        html += `<div class="output-table" data-category="${category}">`;
        html += `<div class="output-table-header">`;
        html += `<h5>${category}</h5>`;
        html += `<button class="output-table-copy-btn" onclick="copyTableCategory('${category}')">Copy</button>`;
        html += `</div>`;
        html += `<table>`;
        html += `<tr><th>Date</th>`;
        for (const col of cols) {
          html += `<th>${col.name}</th>`;
        }
        html += `</tr>`;

        for (const date of sortedDates) {
          if (!isWithinPresetRange(date)) continue;
          html += `<tr><td>${formatDate(date)}</td>`;

          for (const col of cols) {
            const dataPoint = parsed.seriesData[col.name].find(dp => dp.date.getTime() === date.getTime());
            if (dataPoint) {
              const isHigh = col.refHigh != null && dataPoint.value > col.refHigh;
              const isLow = col.refLow != null && dataPoint.value < col.refLow;
              const flag = isHigh ? ' (H)' : (isLow ? ' (L)' : '');
              const colorClass = isHigh ? 'high' : (isLow ? 'low' : '');
              html += `<td><span class="${colorClass}">${dataPoint.value}${flag}</span></td>`;
            } else {
              html += `<td>â€”</td>`;
            }
          }

          html += `</tr>`;
        }

        html += `</table>`;
        html += `</div>`;
      }

      return html;
    }

    function updateAndRenderChart(parsed) {
      // Store the full parsed data
      fullParsedData = parsed;

      if (!parsed) {
        dateRangeControls.style.display = 'none';
        columnSelector.style.display = 'none';
        renderChart(null);
        return;
      }

      if (parsed.type === 'single') {
        // Single column mode
        dateRangeControls.style.display = parsed.dateGroups && parsed.dateGroups.length > 0 ? 'flex' : 'none';
        columnSelector.style.display = 'none';

        if (parsed.dateGroups && parsed.dateGroups.length > 0) {
          populateDateDropdowns(parsed.dateGroups);
          applyRangePresetToDropdowns();
          renderChartWithDateRange();
        } else {
          renderChart(null);
        }
      } else if (parsed.type === 'table') {
        // Multi-column mode
        renderColumnSelector(parsed);

        // Populate date dropdowns for table mode
        const allDates = getAllDatesFromTableData(parsed);
        if (allDates.length > 0) {
          dateRangeControls.style.display = 'flex';
          populateDateDropdownsFromDates(allDates);
          applyRangePresetToDropdowns();
        } else {
          dateRangeControls.style.display = 'none';
        }

        renderChartFromParsedData();
      }
    }

    function getAllDatesFromTableData(parsed) {
      const dateSet = new Set();
      for (const col of parsed.columns) {
        for (const dp of parsed.seriesData[col.name]) {
          dateSet.add(dp.date.getTime());
        }
      }
      return Array.from(dateSet).map(t => new Date(t)).sort((a, b) => a - b);
    }

    function populateDateDropdownsFromDates(dates) {
      // Clear existing options
      startDateSelect.innerHTML = '';
      endDateSelect.innerHTML = '';

      // Populate both dropdowns with the dates
      dates.forEach((date, index) => {
        const dateStr = formatDate(date);
        const startOption = document.createElement('option');
        startOption.value = index;
        startOption.textContent = dateStr;
        startDateSelect.appendChild(startOption);

        const endOption = document.createElement('option');
        endOption.value = index;
        endOption.textContent = dateStr;
        endDateSelect.appendChild(endOption);
      });

      // Reset to show full date range (earliest to latest)
      startDateSelect.value = '0';
      endDateSelect.value = (dates.length - 1).toString();

      // Reset preset to All when new data arrives
      rangePreset = 'all';
      if (rangeAllRadio) rangeAllRadio.checked = true;
    }

    function renderChartFromParsedData() {
      if (!fullParsedData || fullParsedData.type !== 'table') return;

      // Get selected columns
      const visibleColumns = fullParsedData.columns.filter(col => seriesVisibility[col.name]);

      if (visibleColumns.length === 0) {
        renderMultiSeriesChart(null);
        return;
      }

      // Get date range filter if available
      let startDate = null;
      let endDate = null;
      if (startDateSelect.options.length > 0 && endDateSelect.options.length > 0) {
        const allDates = getAllDatesFromTableData(fullParsedData);
        const startIdx = parseInt(startDateSelect.value, 10);
        const endIdx = parseInt(endDateSelect.value, 10);

        if (!isNaN(startIdx) && !isNaN(endIdx) && startIdx < allDates.length && endIdx < allDates.length) {
          startDate = allDates[startIdx];
          endDate = new Date(allDates[endIdx].getTime() + 24 * 60 * 60 * 1000 - 1); // End of day
        }
      }

      // Build multi-series data
      const multiSeriesData = {
        columns: visibleColumns,
        seriesData: {},
        type: 'table'
      };

      for (const col of visibleColumns) {
        // Filter by date range if specified
        let seriesPoints = fullParsedData.seriesData[col.name];
        if (startDate && endDate) {
          seriesPoints = seriesPoints.filter(dp => dp.date >= startDate && dp.date <= endDate);
        }
        // Also apply preset (CPRS week) filter
        seriesPoints = seriesPoints.filter(dp => isWithinPresetRange(dp.date));
        multiSeriesData.seriesData[col.name] = seriesPoints;
      }

      renderMultiSeriesChart(multiSeriesData);
    }

    function renderChartWithDateRange() {
      if (!fullParsedData) return;

      // If this is table data, use the multi-series rendering instead
      if (fullParsedData.type === 'table') {
        renderChartFromParsedData();
        return;
      }

      const startIdx = parseInt(startDateSelect.value, 10);
      const endIdx = parseInt(endDateSelect.value, 10);

      // Get the date range from the original dateGroups
      const startDate = fullParsedData.dateGroups[startIdx].date;
      const endDate = fullParsedData.dateGroups[endIdx].date;

      // Extend endDate to the end of that day (23:59:59.999)
      // This ensures all data points on the end date are included
      const msPerDay = 24 * 60 * 60 * 1000;
      const endDateInclusive = new Date(endDate.getTime() + msPerDay - 1);

      // Filter dataPoints to include only those within the selected range
      // Note: dataPoints may have interpolated dates for multiple values per day
      const filteredDataPoints = fullParsedData.dataPoints.filter(dp => {
        return dp.date >= startDate && dp.date <= endDateInclusive && isWithinPresetRange(dp.date);
      });

      // Create a filtered version of the parsed data
      const filteredParsed = {
        type: 'single',
        dataPoints: filteredDataPoints,
        dateGroups: fullParsedData.dateGroups,
        refLow: fullParsedData.refLow,
        refHigh: fullParsedData.refHigh,
        labName: fullParsedData.labName
      };

      renderChart(filteredParsed);
    }

    function pad(str, width) {
      // Right-align by padding on the left with spaces (matching CPRS formatter)
      const s = String(str);
      return s.length >= width ? s : ' '.repeat(width - s.length) + s;
    }

    function replaceHTMLTags(str) {
      // Remove HTML tags to get actual text length
      return str.replace(/<[^>]*>/g, '');
    }

    // CPRS Formatter caps plain-text output width (so it can be pasted into EMRs like Epic
    // without turning into a super-wide table). This is the key knob.
    const MAX_PLAIN_TEXT_WIDTH = 55;

    function getPlainTextColWidth(colName) {
      const originalName = String(colName).toUpperCase();
      const shortName = shortHeaders[originalName] || colName;
      return Math.max(6, shortName.length + 1);
    }

    function chunkColumnsByWidth(cols, maxWidth = MAX_PLAIN_TEXT_WIDTH) {
      // Split columns into groups such that each group's header row stays <= maxWidth.
      // This preserves alignment (monospace) while preventing a huge horizontal table.
      const groups = [];
      let cur = [];
      let curWidth = 0;

      for (const col of cols) {
        const w = getPlainTextColWidth(col.name);
        // If adding this column would exceed the cap, start a new chunk.
        if (cur.length > 0 && curWidth + w > maxWidth) {
          groups.push(cur);
          cur = [];
          curWidth = 0;
        }
        cur.push(col);
        curWidth += w;
      }

      if (cur.length > 0) groups.push(cur);
      return groups;
    }

    function generatePlainTextForCategory(parsed, category, cols) {
      // Helper function to generate plain text for a single category (matching CPRS formatter)
      let plainText = category.toUpperCase() + ':\n';

      // Get all unique dates across all columns in this category
      const allDates = new Set();
      for (const col of cols) {
        for (const dataPoint of parsed.seriesData[col.name]) {
          allDates.add(dataPoint.date.getTime());
        }
      }
      const sortedDates = Array.from(allDates).map(t => new Date(t)).sort((a, b) => b - a);

      // Build header row using short column names
      let headerRow = '';
      for (const col of cols) {
        const originalName = col.name.toUpperCase();
        const shortName = shortHeaders[originalName] || col.name;
        const colWidth = Math.max(6, shortName.length + 1);
        headerRow += shortName + ' '.repeat(Math.max(0, colWidth - shortName.length));
      }
      plainText += headerRow.trimEnd() + '\n';

      // Add separator line (matching CPRS formatter width cap)
      const separatorLength = Math.min(replaceHTMLTags(headerRow).length, MAX_PLAIN_TEXT_WIDTH);
      plainText += '='.repeat(separatorLength) + '\n';

      // Build data rows
      for (const date of sortedDates) {
        if (!isWithinPresetRange(date)) continue;
        let row = '';

        for (const col of cols) {
          const originalName = col.name.toUpperCase();
          const shortName = shortHeaders[originalName] || col.name;
          const colWidth = Math.max(6, shortName.length + 1);

          const dataPoint = parsed.seriesData[col.name].find(dp => dp.date.getTime() === date.getTime());
          if (dataPoint) {
            const isHigh = col.refHigh != null && dataPoint.value > col.refHigh;
            const isLow = col.refLow != null && dataPoint.value < col.refLow;

            // Build value string with color tags (like CPRS formatter)
            // NO (H) or (L) text in plain text mode - only color coding
            let valueStr;
            if (isHigh) {
              valueStr = "<span style='color: red; font-weight: bold'>" + dataPoint.value + "</span>";
            } else if (isLow) {
              valueStr = "<span style='color: blue; font-weight: bold'>" + dataPoint.value + "</span>";
            } else {
              valueStr = String(dataPoint.value);
            }

            // Pad to column width based on visible text length (excluding HTML tags)
            const spacesNeeded = Math.max(0, colWidth - replaceHTMLTags(valueStr).length);
            row += valueStr + ' '.repeat(spacesNeeded);
          } else {
            row += ' '.repeat(colWidth);
          }
        }

        row += ' @ ' + formatDate(date);
        plainText += row.trimEnd() + '\n';
      }

      return plainText;
    }

    function generatePlainTextOutput(parsed) {
      if (!parsed || parsed.type !== 'table') {
        return null;
      }

      // Group columns by category
      const categorized = {};
      for (const col of parsed.columns) {
        const cat = col.category || 'Other';
        if (!categorized[cat]) categorized[cat] = [];
        categorized[cat].push(col);
      }

      let html = '';

      // Order categories to match CPRS formatter
      const categoryOrder = ['Chem', 'CBC', 'Diff', 'Cardiac', 'Liver', 'Coags', 'Lipid-A1c', 'Endocrine', 'Other'];
      const sortedCategories = categoryOrder.filter(cat => categorized[cat]);

      for (const category of sortedCategories) {
        if (categorized[category].length === 0) continue;

        // Respect the column selections (checkboxes) for plain-text output as well.
        const cols = categorized[category].filter(c => selectedColumns.has(c.name));
        if (cols.length === 0) continue;

        const colGroups = chunkColumnsByWidth(cols, MAX_PLAIN_TEXT_WIDTH);

        for (let gi = 0; gi < colGroups.length; gi++) {
          const group = colGroups[gi];
          const categoryKey = colGroups.length === 1 ? category : `${category}-${gi + 1}`;
          const categoryLabel = colGroups.length === 1 ? category : `${category} (${gi + 1}/${colGroups.length})`;

          const plainText = generatePlainTextForCategory(parsed, categoryLabel, group);

          // The plainText contains HTML span tags for coloring when displayed
          let sectionHtml = plainText;

          // For copying, we need a clean version without HTML tags
          const plainTextForCopy = plainText.replace(/<[^>]*>/g, '');

          html += `<div class="plain-text-section" data-category="${categoryKey}">`;
          html += `<div class="plain-text-header">`;
          html += `<button class="output-table-copy-btn plain-text-copy-btn" onclick="copyPlainTextCategory('${categoryKey}')">Copy</button>`;
          html += `</div>`;
          html += `<div class="plain-text-content" data-plain-text="${encodeURIComponent(plainTextForCopy)}">${sectionHtml}</div>`;
          html += `</div>`;
        }
      }

      return html;
    }

    function generateFormattedOutput(parsed) {
      if (!parsed) {
        outputArea.innerHTML = '<span style="color: #999;">No data to display</span>';
        outputArea.classList.remove('plain-text-mode');
        return;
      }

      // Plain text format
      if (isPlainTextFormat && parsed.type === 'table') {
        const html = generatePlainTextOutput(parsed);
        if (html) {
          outputArea.innerHTML = html;
          outputArea.style.fontFamily = 'Courier, monospace';
          outputArea.style.fontSize = '11px';
          outputArea.classList.add('plain-text-mode');
          return;
        }
      }

      // Reset font styling for table view
      outputArea.style.fontFamily = 'monospace';
      outputArea.style.fontSize = '14px';
      outputArea.classList.remove('plain-text-mode');

      if (parsed.type === 'table') {
        // Generate categorized table output
        const html = generateCategorizedOutput(parsed);
        outputArea.innerHTML = html || '<span style="color: #999;">No data to display</span>';
      } else {
        // Single column output
        const { dataPoints, refLow, refHigh, labName } = parsed;

        // Generate output in reverse chronological order (most recent first)
        const sortedPoints = [...dataPoints].sort((a, b) => b.date - a.date);

        // Find max width for value column (including flag) for alignment
        const maxValueWidth = Math.max(...sortedPoints.map(d => {
          const isHigh = refHigh != null && d.value > refHigh;
          const isLow = refLow != null && d.value < refLow;
          const flag = isHigh ? ' (H)' : (isLow ? ' (L)' : '');
          return (d.value + flag).length;
        }));

        const header = labName || 'Lab Value';
        let html = `<strong>${header}:</strong>\n`;
        for (const d of sortedPoints) {
          const dateStr = formatDate(d.date);
          const isHigh = refHigh != null && d.value > refHigh;
          const isLow = refLow != null && d.value < refLow;

          const rawValue = d.value;
          const flag = isHigh ? ' (H)' : (isLow ? ' (L)' : '');
          const paddedValue = (rawValue + flag).padEnd(maxValueWidth);

          let valueStr;
          if (isHigh) {
            valueStr = `<span class="high">${paddedValue}</span>`;
          } else if (isLow) {
            valueStr = `<span class="low">${paddedValue}</span>`;
          } else {
            valueStr = paddedValue;
          }

          html += `  ${valueStr} @ ${dateStr}\n`;
        }

        outputArea.innerHTML = html;
      }
    }

    function renderMultiSeriesChart(multiData) {
      // Update formatted output
      generateFormattedOutput(fullParsedData);

      if (!multiData || multiData.columns.length === 0) {
        statusEl.textContent = 'No columns selected';
        chartContainer.innerHTML = '';
        legend.style.display = 'none';
        trendInfo.style.display = 'none';
        return;
      }

      const numSeries = multiData.columns.length;
      const useNormalizedAxis = numSeries > 1;

      // Get all data points across all series
      let allDates = new Set();
      for (const col of multiData.columns) {
        for (const dp of multiData.seriesData[col.name]) {
          allDates.add(dp.date.getTime());
        }
      }
      allDates = Array.from(allDates).map(t => new Date(t)).sort((a, b) => a - b);

      if (allDates.length === 0) {
        statusEl.textContent = 'No data points';
        chartContainer.innerHTML = '';
        return;
      }

      const minDate = allDates[0];
      const maxDate = allDates[allDates.length - 1];
      const dateRange = maxDate - minDate;
      const datePadding = dateRange * 0.05;
      const minTime = minDate.getTime() - datePadding;
      const maxTime = maxDate.getTime() + datePadding;

      // Normalize function
      const normalizeValue = (value, refLow, refHigh) => {
        if (!useNormalizedAxis || refLow == null || refHigh == null) {
          return value;
        }
        const refMid = (refLow + refHigh) / 2;
        const refRange = refHigh - refLow;
        return 100 + ((value - refMid) / refRange) * 100;
      };

      // Determine Y-axis scale
      let yScale;
      if (useNormalizedAxis) {
        // Normalized: auto-scale based on actual data
        // First normalize all values to get the range
        let minNormalized = Infinity;
        let maxNormalized = -Infinity;

        for (const col of multiData.columns) {
          for (const dp of multiData.seriesData[col.name]) {
            const normalized = normalizeValue(dp.value, col.refLow, col.refHigh);
            minNormalized = Math.min(minNormalized, normalized);
            maxNormalized = Math.max(maxNormalized, normalized);
          }
        }

        // Ensure 100% is always visible (minimum top of scale is 100%)
        maxNormalized = Math.max(maxNormalized, 100);

        // Add some padding
        const range = maxNormalized - minNormalized;
        const padding = range * 0.1;
        yScale = niceScale(minNormalized - padding, maxNormalized + padding, 6);

        statusEl.textContent = `Showing ${numSeries} series (normalized to % of reference range)`;
      } else {
        // Single series: use actual values
        const col = multiData.columns[0];
        const values = multiData.seriesData[col.name].map(dp => dp.value);
        let minValue = Math.min(...values);
        let maxValue = Math.max(...values);

        if (col.refHigh != null) {
          maxValue = Math.max(maxValue, col.refHigh);
          minValue = Math.min(minValue, col.refLow);
        }

        yScale = niceScale(minValue * 0.9, maxValue * 1.1, 6);
        statusEl.textContent = `Showing ${col.name} | ${multiData.seriesData[col.name].length} data point(s)` +
          (col.refHigh != null ? ` | Ref range: ${col.refLow}â€“${col.refHigh}` : '');
      }

      // Get container dimensions
      const rect = chartContainer.getBoundingClientRect();
      const width = rect.width || 600;
      const height = rect.height || 400;
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      // Scale functions
      const xScale = (date) => {
        const t = date.getTime();
        return margin.left + ((t - minTime) / (maxTime - minTime)) * innerWidth;
      };

      const yScaleFn = (value) => {
        return margin.top + innerHeight - ((value - yScale.min) / (yScale.max - yScale.min)) * innerHeight;
      };

      // Build SVG
      let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;

      // Y-axis grid lines and labels
      for (const v of yScale.values) {
        const y = yScaleFn(v);
        svg += `<line class="grid-line" x1="${margin.left}" y1="${y}" x2="${width - margin.right}" y2="${y}" />`;
        let label = v.toFixed(useNormalizedAxis ? 0 : 2);
        if (useNormalizedAxis) label += '%';
        svg += `<text class="axis-label" x="${margin.left - 10}" y="${y + 4}" text-anchor="end">${label}</text>`;
      }

      // X-axis grid lines and labels (years)
      const yearTicks = getYearTicks(new Date(minTime), new Date(maxTime));
      for (const date of yearTicks) {
        const x = xScale(date);
        if (x >= margin.left && x <= width - margin.right) {
          svg += `<line class="grid-line" x1="${x}" y1="${margin.top}" x2="${x}" y2="${height - margin.bottom}" />`;
          svg += `<text class="axis-label" x="${x}" y="${height - margin.bottom + 20}" text-anchor="middle">${formatYear(date)}</text>`;
        }
      }

      // Axis lines
      svg += `<line stroke="#333" stroke-width="1" x1="${margin.left}" y1="${height - margin.bottom}" x2="${width - margin.right}" y2="${height - margin.bottom}" />`;
      svg += `<line stroke="#333" stroke-width="1" x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${height - margin.bottom}" />`;

      // Axis titles
      const yAxisLabel = useNormalizedAxis ? '% of Reference Range' : multiData.columns[0].name;
      svg += `<text class="axis-title" x="${width / 2}" y="${height - 5}" text-anchor="middle">Date</text>`;
      svg += `<text class="axis-title" x="${15}" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 15, ${height / 2})">${yAxisLabel}</text>`;

      // Reference lines (only for single series with actual values)
      if (!useNormalizedAxis && multiData.columns[0].refHigh != null) {
        const col = multiData.columns[0];
        const refYHigh = yScaleFn(col.refHigh);
        const refYLow = yScaleFn(col.refLow);
        svg += `<line class="ref-line" x1="${margin.left}" y1="${refYHigh}" x2="${width - margin.right}" y2="${refYHigh}" />`;
        svg += `<line class="ref-line" x1="${margin.left}" y1="${refYLow}" x2="${width - margin.right}" y2="${refYLow}" />`;
      }

      // For normalized mode, draw reference zone at 100%
      if (useNormalizedAxis) {
        const y100 = yScaleFn(100);
        svg += `<line stroke="#4caf50" stroke-width="2" stroke-dasharray="2,2" x1="${margin.left}" y1="${y100}" x2="${width - margin.right}" y2="${y100}" />`;
      }

      // Linear regression for single series
      let regressionInfo = null;
      if (multiData.columns.length === 1) {
        const col = multiData.columns[0];
        const dataPoints = multiData.seriesData[col.name].sort((a, b) => a.date - b.date);

        if (dataPoints.length >= 2) {
          const regression = linearRegression(dataPoints);
          if (regression) {
            const { slope, intercept, firstTime, msPerDay } = regression;

            // Calculate y values at the start and end of the x-axis
            const x1Days = (minTime - firstTime) / msPerDay;
            const x2Days = (maxTime - firstTime) / msPerDay;
            let y1Value = intercept + slope * x1Days;
            let y2Value = intercept + slope * x2Days;

            // If using normalized axis, normalize the regression line values
            if (useNormalizedAxis) {
              y1Value = normalizeValue(y1Value, col.refLow, col.refHigh);
              y2Value = normalizeValue(y2Value, col.refLow, col.refHigh);
            }

            const lineX1 = margin.left;
            const lineX2 = width - margin.right;
            const lineY1 = yScaleFn(y1Value);
            const lineY2 = yScaleFn(y2Value);

            svg += `<line class="trend-line" x1="${lineX1}" y1="${lineY1}" x2="${lineX2}" y2="${lineY2}" />`;

            // Calculate slope info
            const dataSpanDays = (maxDate - minDate) / msPerDay;
            let slopeValue, timeUnit;

            if (dataSpanDays < 60) {
              slopeValue = slope;
              timeUnit = 'day';
            } else if (dataSpanDays < 365) {
              slopeValue = slope * 30.44;
              timeUnit = 'month';
            } else {
              slopeValue = slope * 365.25;
              timeUnit = 'year';
            }

            regressionInfo = { slopeValue, timeUnit, col };
          }
        }
      }

      // Draw each series
      const seriesMetadata = [];
      const outOfRangeColor = '#dc3545'; // Bootstrap danger red

      for (const col of multiData.columns) {
        const color = columnColors[col.name];
        const dataPoints = multiData.seriesData[col.name].sort((a, b) => a.date - b.date);

        // Normalize data if needed
        const normalizedPoints = dataPoints.map(dp => ({
          ...dp,
          displayValue: normalizeValue(dp.value, col.refLow, col.refHigh)
        }));

        // Data line
        if (normalizedPoints.length > 1) {
          let pathD = `M ${xScale(normalizedPoints[0].date)} ${yScaleFn(normalizedPoints[0].displayValue)}`;
          for (let i = 1; i < normalizedPoints.length; i++) {
            pathD += ` L ${xScale(normalizedPoints[i].date)} ${yScaleFn(normalizedPoints[i].displayValue)}`;
          }
          svg += `<path fill="none" stroke="${color}" stroke-width="2" d="${pathD}" data-series="${col.name}" style="cursor:pointer" />`;
        }

        // Data points
        for (let i = 0; i < normalizedPoints.length; i++) {
          const dp = normalizedPoints[i];
          const x = xScale(dp.date);
          const y = yScaleFn(dp.displayValue);
          const isOutOfRange = (col.refHigh != null && dp.value > col.refHigh) || (col.refLow != null && dp.value < col.refLow);

          if (isOutOfRange) {
            // Hollow red circle for out-of-range values
            svg += `<circle fill="white" stroke="${outOfRangeColor}" stroke-width="2" cx="${x}" cy="${y}" r="5" data-series="${col.name}" data-index="${i}" class="out-of-range" style="cursor:pointer" />`;

            // Add H or L label
            const isHigh = col.refHigh != null && dp.value > col.refHigh;
            const label = isHigh ? 'H' : 'L';
            svg += `<text x="${x}" y="${y + 1}" text-anchor="middle" font-size="7" font-weight="bold" fill="${outOfRangeColor}" pointer-events="none">${label}</text>`;
          } else {
            // Normal filled circle for in-range values
            svg += `<circle fill="${color}" cx="${x}" cy="${y}" r="4" data-series="${col.name}" data-index="${i}" style="cursor:pointer" />`;
          }
        }

        seriesMetadata.push({ col, dataPoints, normalizedPoints, color });
      }

      svg += '</svg>';
      chartContainer.innerHTML = svg;

      // Add hover interactions to paths (lines)
      const paths = chartContainer.querySelectorAll('path[data-series]');
      paths.forEach(path => {
        path.addEventListener('mouseenter', () => {
          const seriesName = path.getAttribute('data-series');
          highlightSeries(seriesName);
        });

        path.addEventListener('mouseleave', () => {
          unhighlightAllSeries();
        });
      });

      // Add hover interactions to points
      const points = chartContainer.querySelectorAll('circle');
      points.forEach(point => {
        const originalFill = point.getAttribute('fill');
        const originalStroke = point.getAttribute('stroke');
        const originalStrokeWidth = point.getAttribute('stroke-width');
        const originalR = point.getAttribute('r');

        point.addEventListener('mouseenter', (e) => {
          const seriesName = point.getAttribute('data-series');
          const idx = parseInt(point.getAttribute('data-index'), 10);
          const meta = seriesMetadata.find(m => m.col.name === seriesName);
          if (meta) {
            const dp = meta.dataPoints[idx];
            const col = meta.col;

            // Check if value is out of range
            const isHigh = col.refHigh != null && dp.value > col.refHigh;
            const isLow = col.refLow != null && dp.value < col.refLow;
            const flag = isHigh ? ' (H)' : (isLow ? ' (L)' : '');

            tooltip.textContent = `${seriesName}: ${dp.value}${flag} @ ${formatDate(dp.date)}`;
            tooltip.style.display = 'block';

            // Make point larger and add/enhance stroke
            point.setAttribute('r', parseFloat(originalR) + 2);
            if (originalFill === 'white') {
              // Out-of-range point: make stroke thicker
              point.setAttribute('stroke-width', '3');
            } else {
              // Normal point: add white stroke
              point.setAttribute('stroke', 'white');
              point.setAttribute('stroke-width', '2');
            }

            // Highlight the entire series
            highlightSeries(seriesName);
          }
        });

        point.addEventListener('mousemove', (e) => {
          tooltip.style.left = (e.pageX + 10) + 'px';
          tooltip.style.top = (e.pageY - 30) + 'px';
        });

        point.addEventListener('mouseleave', () => {
          tooltip.style.display = 'none';

          // Restore original appearance
          point.setAttribute('r', originalR);
          if (originalStroke) {
            point.setAttribute('stroke', originalStroke);
            point.setAttribute('stroke-width', originalStrokeWidth);
          } else {
            point.removeAttribute('stroke');
            point.removeAttribute('stroke-width');
          }

          // Unhighlight series
          unhighlightAllSeries();
        });
      });

      // Update legend
      legend.style.display = 'flex';
      legend.innerHTML = '';
      for (const meta of seriesMetadata) {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `
          <div class="legend-line" style="background: ${meta.color}"></div>
          <span>${meta.col.name}</span>
        `;
        legend.appendChild(item);
      }

      // Show trend line in legend if we have regression
      if (regressionInfo) {
        const trendItem = document.createElement('div');
        trendItem.className = 'legend-item';
        trendItem.innerHTML = `
          <div class="legend-line" style="background: repeating-linear-gradient(90deg, #4caf50 0px, #4caf50 4px, transparent 4px, transparent 8px);"></div>
          <span>Linear Regression</span>
        `;
        legend.appendChild(trendItem);
      }

      // Display regression slope info
      if (regressionInfo) {
        const { slopeValue, timeUnit, col } = regressionInfo;
        const slopeSign = slopeValue >= 0 ? '+' : '';
        const unit = useNormalizedAxis ? '% of ref range' : (col.name.includes('Sodium') || col.name.includes('Potassium') || col.name.includes('Chloride') ? 'mmol/L' : 'units');
        trendInfo.textContent = `Linear Regression Slope: ${slopeSign}${slopeValue.toFixed(3)} ${unit} per ${timeUnit}`;
        trendInfo.style.display = 'block';
      } else {
        trendInfo.style.display = 'none';
      }

      refLegend.style.display = 'none';
      trendLegend.style.display = 'none';
    }

    function renderChart(parsed) {
      // Update formatted output
      generateFormattedOutput(parsed);

      if (!parsed) {
        statusEl.textContent = 'No valid data found.';
        chartContainer.innerHTML = '';
        legend.style.display = 'none';
        trendInfo.style.display = 'none';
        return;
      }

      const { dataPoints, refLow, refHigh, labName } = parsed;
      const displayName = labName || 'Lab Value';

      statusEl.textContent = `Parsed ${dataPoints.length} data point(s)` +
        (refHigh != null ? ` | Ref range: ${refLow}â€“${refHigh}` : '');

      legend.style.display = 'flex';
      legendLabel.textContent = displayName;
      refLegend.style.display = refHigh != null ? 'flex' : 'none';
      trendLegend.style.display = dataPoints.length >= 2 ? 'flex' : 'none';

      // Get container dimensions
      const rect = chartContainer.getBoundingClientRect();
      const width = rect.width || 600;
      const height = rect.height || 400;
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      // Calculate scales
      const minDate = dataPoints[0].date;
      const maxDate = dataPoints[dataPoints.length - 1].date;
      const dateRange = maxDate - minDate;
      const datePadding = dateRange * 0.05;

      const minTime = minDate.getTime() - datePadding;
      const maxTime = maxDate.getTime() + datePadding;

      let minValue = Math.min(...dataPoints.map(d => d.value));
      let maxValue = Math.max(...dataPoints.map(d => d.value));

      if (refHigh != null) {
        maxValue = Math.max(maxValue, refHigh);
        minValue = Math.min(minValue, refLow);
      }

      const yScale = niceScale(minValue * 0.9, maxValue * 1.1, 6);

      // Scale functions
      const xScale = (date) => {
        const t = date.getTime();
        return margin.left + ((t - minTime) / (maxTime - minTime)) * innerWidth;
      };

      const yScaleFn = (value) => {
        return margin.top + innerHeight - ((value - yScale.min) / (yScale.max - yScale.min)) * innerHeight;
      };

      // Build SVG
      let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;

      // Y-axis grid lines and labels
      for (const v of yScale.values) {
        const y = yScaleFn(v);
        svg += `<line class="grid-line" x1="${margin.left}" y1="${y}" x2="${width - margin.right}" y2="${y}" />`;
        svg += `<text class="axis-label" x="${margin.left - 10}" y="${y + 4}" text-anchor="end">${v.toFixed(2)}</text>`;
      }

      // X-axis grid lines and labels (years)
      const yearTicks = getYearTicks(new Date(minTime), new Date(maxTime));
      for (const date of yearTicks) {
        const x = xScale(date);
        if (x >= margin.left && x <= width - margin.right) {
          svg += `<line class="grid-line" x1="${x}" y1="${margin.top}" x2="${x}" y2="${height - margin.bottom}" />`;
          svg += `<text class="axis-label" x="${x}" y="${height - margin.bottom + 20}" text-anchor="middle">${formatYear(date)}</text>`;
        }
      }

      // Axis lines
      svg += `<line stroke="#333" stroke-width="1" x1="${margin.left}" y1="${height - margin.bottom}" x2="${width - margin.right}" y2="${height - margin.bottom}" />`;
      svg += `<line stroke="#333" stroke-width="1" x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${height - margin.bottom}" />`;

      // Axis titles
      svg += `<text class="axis-title" x="${width / 2}" y="${height - 5}" text-anchor="middle">Date</text>`;
      svg += `<text class="axis-title" x="${15}" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 15, ${height / 2})">${displayName}</text>`;

      // Reference lines (upper and lower)
      if (refHigh != null) {
        const refYHigh = yScaleFn(refHigh);
        svg += `<line class="ref-line" x1="${margin.left}" y1="${refYHigh}" x2="${width - margin.right}" y2="${refYHigh}" />`;
      }
      if (refLow != null) {
        const refYLow = yScaleFn(refLow);
        svg += `<line class="ref-line" x1="${margin.left}" y1="${refYLow}" x2="${width - margin.right}" y2="${refYLow}" />`;
      }

      // Linear regression line
      const regression = linearRegression(dataPoints);
      if (regression) {
        const { slope, intercept, firstTime, msPerDay } = regression;

        // Calculate y values at the start and end of the x-axis
        const x1Days = (minTime - firstTime) / msPerDay;
        const x2Days = (maxTime - firstTime) / msPerDay;
        const y1Value = intercept + slope * x1Days;
        const y2Value = intercept + slope * x2Days;

        const lineX1 = margin.left;
        const lineX2 = width - margin.right;
        const lineY1 = yScaleFn(y1Value);
        const lineY2 = yScaleFn(y2Value);

        svg += `<line class="trend-line" x1="${lineX1}" y1="${lineY1}" x2="${lineX2}" y2="${lineY2}" />`;

        // Display slope info with appropriate time unit based on data span
        const dataSpanDays = (maxDate - minDate) / msPerDay;
        let slopeValue, timeUnit;

        if (dataSpanDays < 60) {
          // Less than 2 months: show per day
          slopeValue = slope;
          timeUnit = 'day';
        } else if (dataSpanDays < 365) {
          // Less than 1 year: show per month
          slopeValue = slope * 30.44; // average days per month
          timeUnit = 'month';
        } else {
          // 1 year or more: show per year
          slopeValue = slope * 365.25;
          timeUnit = 'year';
        }

        const slopeSign = slopeValue >= 0 ? '+' : '';
        trendInfo.textContent = `Linear Regression Slope: ${slopeSign}${slopeValue.toFixed(3)} mg/dL per ${timeUnit}`;
        trendInfo.style.display = 'block';
      } else {
        trendInfo.style.display = 'none';
      }

      // Data line
      if (dataPoints.length > 1) {
        let pathD = `M ${xScale(dataPoints[0].date)} ${yScaleFn(dataPoints[0].value)}`;
        for (let i = 1; i < dataPoints.length; i++) {
          pathD += ` L ${xScale(dataPoints[i].date)} ${yScaleFn(dataPoints[i].value)}`;
        }
        svg += `<path class="data-line" d="${pathD}" />`;
      }

      // Data points
      for (let i = 0; i < dataPoints.length; i++) {
        const d = dataPoints[i];
        const x = xScale(d.date);
        const y = yScaleFn(d.value);
        const isOutOfRange = (refHigh != null && d.value > refHigh) || (refLow != null && d.value < refLow);
        const pointClass = isOutOfRange ? 'data-point out-of-range' : 'data-point';
        svg += `<circle class="${pointClass}" cx="${x}" cy="${y}" r="4" data-index="${i}" />`;
      }

      svg += '</svg>';
      chartContainer.innerHTML = svg;

      // Add hover interactions
      const points = chartContainer.querySelectorAll('.data-point');
      points.forEach(point => {
        point.addEventListener('mouseenter', (e) => {
          const idx = parseInt(point.getAttribute('data-index'), 10);
          const d = dataPoints[idx];
          tooltip.textContent = `${formatDate(d.date)}: ${d.value} mg/dL`;
          tooltip.style.display = 'block';
        });

        point.addEventListener('mousemove', (e) => {
          tooltip.style.left = (e.pageX + 10) + 'px';
          tooltip.style.top = (e.pageY - 30) + 'px';
        });

        point.addEventListener('mouseleave', () => {
          tooltip.style.display = 'none';
        });
      });
    }

    // Handle resize
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        if (fullParsedData) {
          renderChartWithDateRange();
        }
      }, 100);
    });

    // Debounce input
    let debounceTimer = null;
    textarea.addEventListener('input', () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const parsed = parseData(textarea.value);
        updateAndRenderChart(parsed);
      }, 300);
    });

    // Preload example data (multi-column electrolyte panel)
    textarea.value = `    Sodium    Potassium    Chloride    CO2
Latest Ref Rng    135 - 146 mmol/L    3.5 - 5.1 mmol/L    98 - 110 mmol/L    22 - 29 mmol/L
12/23/2016    139    4.0    103    28
5/24/2017    137    3.8    100    25
5/25/2017    140    3.2 (L)    104    29
5/26/2017    135    3.4 (L)    101    25
11/6/2017    142    3.4 (L)    103    30 (H)
4/9/2018    137    4.1    98    27
6/8/2018    139    4.7    100    29
10/3/2018    141    3.9    103    28
2/18/2019    144    4.7    101    34 (H)
7/5/2019    139    3.3 (L)    100    30 (H)
10/10/2019    136    5.9 (H)    103    25
10/16/2019    136    4.9    100    26
12/17/2019    142    3.4 (L)    101    34 (H)
2/14/2020    137    4.5    102    27
9/27/2021    140    4.5    99    31 (H)
4/27/2022    138    4.8    99    28
8/2/2023    143    4.2    107    29
1/22/2024    142    5.0    105    31 (H)
8/16/2024    140    4.7    107    26
12/16/2024    138    4.4    101    25`;

    // Initial render (slight delay to ensure container has dimensions)
    setTimeout(() => {
      const parsed = parseData(textarea.value);
      updateAndRenderChart(parsed);
    }, 50);
  </script>
</body>
</html>
